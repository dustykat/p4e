{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"P4E Web Notes to Accompany ENGR 1330 at TTU by Theodore G. Cleveland and Farhang Forghanparast with contributions from : Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi Server Host Page Introduction words Document History words Administrator Notes The lead author built these web notes on a Raspberry Pi 4B (4GB) running Ubuntu 20.XX, an Apache Web Server, a JupyterHub (fully encrypted) with iPython extensions, R core, Latex, and MkDocs with extensions. The deployment hardware is an Amazon Web Services Virtual Private Server (Lightsail Instance) in the West Virginia Server Farm (typically the container is run on x86-64 Xeon hardware) Direct access to the notebook directories is on the to-do-list.","title":"Home"},{"location":"#p4e","text":"","title":" P4E "},{"location":"#web-notes-to-accompany-engr-1330-at-ttu","text":"by Theodore G. Cleveland and Farhang Forghanparast with contributions from : Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi Server Host Page","title":"Web Notes to Accompany ENGR 1330 at TTU "},{"location":"#introduction","text":"words","title":"Introduction"},{"location":"#document-history","text":"words","title":"Document History"},{"location":"#administrator-notes","text":"The lead author built these web notes on a Raspberry Pi 4B (4GB) running Ubuntu 20.XX, an Apache Web Server, a JupyterHub (fully encrypted) with iPython extensions, R core, Latex, and MkDocs with extensions. The deployment hardware is an Amazon Web Services Virtual Private Server (Lightsail Instance) in the West Virginia Server Farm (typically the container is run on x86-64 Xeon hardware) Direct access to the notebook directories is on the to-do-list.","title":"Administrator Notes"},{"location":"index.old/","text":"Computational Thinking and Data Science A WebBook to Accompany ENGR 1330 at TTU by Theodore G. Cleveland and Farhang Forghanparast with contributions from : Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi Introduction This on-line workbook is a collection of lessons and workshop contents for ENGR-1330 sections taught bt the first two authors; students in other sections are welcome to use this as a resource with proper attribution (check with your instructor regarding what they will consider acceptable) suggested citation goes here This page is a landing page to access three categories of content; The webbook itself (use navigation bar at top of page), a semester-long course framework, and a collection of supporting data, and worked examples as displayed in the table below. WebBook WebCourse WebData A Textbook Framework - Introduction to Problem Solving - JupyterLab/Python fundamentals - Fundamental Numerical Methods - Data Modeling: Statistics - Data Modeling:Machine Learning A Course Framework - syllabus - workshops(labs) - exercises - exams Support Databases - Databases for lessons, workshops, projects ... - Worked stand-alone examples - Library of useful code fragments Follow this hyperlink to examine the http://CTDS-WebCourse Follow this hyperlink to examine the http://CTDS-WebData Follow this hyperlink to examine the http://CTDS-WebCourse Follow this hyperlink to examine the http://CTDS-WebData At TTU the actual course is accessed from blackboard.ttu.edu , using individual instructor content to replace selected (or all) content in the sample course framework. The lead author uses the entire content herein verbatim; other contribuitors adapt the content to their specific sections. The webbook component is common to all sections. Document History This document is a living document and is updated frequently, Python is an ever evolving tool and stuff that works today will be constructively broken by the development team (python.org) in their quest for continuous improvement. Generally these changes occur in the packages (libraries, external modules) and primative python is quite stable. Administrator Notes The lead author built this webbook/webcourse/webdata on a Raspberry Pi 4B (4GB) running Ubuntu 20.XX, an Apache Web Server, a JupyterHub (fully encrypted) with iPython extensions, R core, Latex, and MkDocs with extensions. The deployment hardware is an Amazon Web Services Virtual Private Server (Lightsail Instance) in the West Virginia Server Farm (typically the container is run on x86-64 Xeon hardware) Direct access to the notebook directories is on the to-do-list. A backup is maintained at https://github.com/dustykat/1330-textbook-webroot .","title":"<p style=\"text-align:center\"> Computational Thinking and Data Science </p>"},{"location":"index.old/#computational-thinking-and-data-science","text":"","title":" Computational Thinking and Data Science "},{"location":"index.old/#a-webbook-to-accompany-engr-1330-at-ttu","text":"by Theodore G. Cleveland and Farhang Forghanparast with contributions from : Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi","title":"A WebBook to Accompany ENGR 1330 at TTU "},{"location":"index.old/#introduction","text":"This on-line workbook is a collection of lessons and workshop contents for ENGR-1330 sections taught bt the first two authors; students in other sections are welcome to use this as a resource with proper attribution (check with your instructor regarding what they will consider acceptable) suggested citation goes here This page is a landing page to access three categories of content; The webbook itself (use navigation bar at top of page), a semester-long course framework, and a collection of supporting data, and worked examples as displayed in the table below. WebBook WebCourse WebData A Textbook Framework - Introduction to Problem Solving - JupyterLab/Python fundamentals - Fundamental Numerical Methods - Data Modeling: Statistics - Data Modeling:Machine Learning A Course Framework - syllabus - workshops(labs) - exercises - exams Support Databases - Databases for lessons, workshops, projects ... - Worked stand-alone examples - Library of useful code fragments Follow this hyperlink to examine the http://CTDS-WebCourse Follow this hyperlink to examine the http://CTDS-WebData Follow this hyperlink to examine the http://CTDS-WebCourse Follow this hyperlink to examine the http://CTDS-WebData At TTU the actual course is accessed from blackboard.ttu.edu , using individual instructor content to replace selected (or all) content in the sample course framework. The lead author uses the entire content herein verbatim; other contribuitors adapt the content to their specific sections. The webbook component is common to all sections.","title":"Introduction"},{"location":"index.old/#document-history","text":"This document is a living document and is updated frequently, Python is an ever evolving tool and stuff that works today will be constructively broken by the development team (python.org) in their quest for continuous improvement. Generally these changes occur in the packages (libraries, external modules) and primative python is quite stable.","title":"Document History"},{"location":"index.old/#administrator-notes","text":"The lead author built this webbook/webcourse/webdata on a Raspberry Pi 4B (4GB) running Ubuntu 20.XX, an Apache Web Server, a JupyterHub (fully encrypted) with iPython extensions, R core, Latex, and MkDocs with extensions. The deployment hardware is an Amazon Web Services Virtual Private Server (Lightsail Instance) in the West Virginia Server Farm (typically the container is run on x86-64 Xeon hardware) Direct access to the notebook directories is on the to-do-list. A backup is maintained at https://github.com/dustykat/1330-textbook-webroot .","title":"Administrator Notes"},{"location":"1-programming/0-introduction/introduction/","text":"introduction Copyright \u00a9 2021 Theodore G. Cleveland and Farhang Forghanparast Last GitHub Commit Date: 13 July 2021 syllabus (link to course syllabus here; possibly include handout of document). Use following syntax to imbed URL into notebook/markdown cell: [link name to display](https://fqdn.filename.pdf) computational thinking concepts jupyterlab/computing environment Computational Thinking Concepts Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing (http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case. CT Foundations CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation) Decomposition Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution. Pattern Recognition Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution. Abstraction Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ... Algorithms Step-by-step instructions of how to solve a problem (https://en.wikipedia.org/wiki/Algorithm). Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input. System Integration (implementation) System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand. Data Science and Practice Data science is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills (https://elitedatascience.com/data-science-resources): Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges About JupyterLab (iPython) Environment The tools: JupyterLab (https://jupyter.org/) is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub (https://github.com/jupyterhub/jupyterhub) is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda (https://www.anaconda.com/) as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). Chromebooks are the main example of ARM-based machines that may be difficult to use with Anaconda, but the it may be a non-issue by the time you read this sentance. This course: You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab environment interprets and runs. About Python The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from (https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html) A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Program. Image from: (https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html) Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence. Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Introduction"},{"location":"1-programming/0-introduction/introduction/#introduction","text":"Copyright \u00a9 2021 Theodore G. Cleveland and Farhang Forghanparast Last GitHub Commit Date: 13 July 2021 syllabus (link to course syllabus here; possibly include handout of document). Use following syntax to imbed URL into notebook/markdown cell: [link name to display](https://fqdn.filename.pdf) computational thinking concepts jupyterlab/computing environment","title":"introduction"},{"location":"1-programming/0-introduction/introduction/#computational-thinking-concepts","text":"Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing (http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case.","title":"Computational Thinking Concepts"},{"location":"1-programming/0-introduction/introduction/#ct-foundations","text":"CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation)","title":"CT Foundations"},{"location":"1-programming/0-introduction/introduction/#decomposition","text":"Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution.","title":"Decomposition"},{"location":"1-programming/0-introduction/introduction/#pattern-recognition","text":"Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution.","title":"Pattern Recognition"},{"location":"1-programming/0-introduction/introduction/#abstraction","text":"Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ...","title":"Abstraction"},{"location":"1-programming/0-introduction/introduction/#algorithms","text":"Step-by-step instructions of how to solve a problem (https://en.wikipedia.org/wiki/Algorithm). Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input.","title":"Algorithms"},{"location":"1-programming/0-introduction/introduction/#system-integration-implementation","text":"System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand.","title":"System Integration (implementation)"},{"location":"1-programming/0-introduction/introduction/#data-science-and-practice","text":"Data science is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills (https://elitedatascience.com/data-science-resources): Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges","title":"Data Science and Practice"},{"location":"1-programming/0-introduction/introduction/#about-jupyterlab-ipython-environment","text":"","title":"About JupyterLab (iPython) Environment"},{"location":"1-programming/0-introduction/introduction/#the-tools","text":"JupyterLab (https://jupyter.org/) is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub (https://github.com/jupyterhub/jupyterhub) is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda (https://www.anaconda.com/) as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). Chromebooks are the main example of ARM-based machines that may be difficult to use with Anaconda, but the it may be a non-issue by the time you read this sentance.","title":"The tools:"},{"location":"1-programming/0-introduction/introduction/#this-course","text":"You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab environment interprets and runs.","title":"This course:"},{"location":"1-programming/0-introduction/introduction/#about-python","text":"The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from (https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html) A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Program. Image from: (https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html) Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.","title":"About Python"},{"location":"1-programming/0-introduction/introduction/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Readings"},{"location":"1-programming/1-problemsolving/problemsolving/","text":"problem solving Copyright \u00a9 2021 Theodore G. Cleveland and Farhang Forghanparast Last GitHub Commit Date: 13 July 2021 a 6-step protocol decomposition ccmr Download this page as a jupyter notebook at http://54.243.252.9/p4e/1-programming/1-problemsolving/problemsolving.ipynb Download the data file referred to herein at http://54.243.252.9/p4e/1-programming/1-problemsolving/data.txt Computational Thinking and Problem Solving Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution. Pattern Recognition refers to finding similarities, or shared characteristics of problems, which allows a complex problem to become easier to solve, and allows use of same solution method for each occurrence of the pattern. Abstraction is the process of identifying important characteristics of the problem and ignore characteristics that are not important. We use these characteristics to create a representation of what we are trying to solve. Algorithms are step-by-step instructions of how to solve a problem System Integration (implementation)is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand. Programming as a problem solving process The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method (https://en.wikipedia.org/wiki/Scientific_method) is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4). Example 1 Problem Solving Process Consider a need to compute an arithmetic mean, what would the process look like? Step 1. Develop script to compute the arithmetic mean of a stream of data of unknown length. Step 2. - Inputs: The data stream - Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. - Outputs: The arithmetic mean \\bar x Step 3. Work a sample problem by-hand for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95 Step 4. Develop a general solution (code) The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. As a recipe (like baking bread) we did the following: Set the sum to zero Set the count to zero Read in the data stream, as each value is read, add it to sum , and increment the count by one when all data are read, compute the mean as: sum/count => result report result Step 5. This step we would code the algorithm expressed in the figure and test it with the by-hand data and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howmany = 0 accumulator = 0 # a variable to accumulate the sum for i in range(len(xlist)): # len is a built-in function that returns how many items in a list accumulator = accumulator + xlist[i] howmany = howmany+1 print(\"arithmetic mean = \",(accumulator/howmany)) arithmetic mean = 30.951999999999998 Step 6. This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howmany = 0 accumulator = 0 # a variable to accumulate the sum for i in range(len(xlist)): # len is a built-in function that returns how many items in a list accumulator = accumulator + xlist[i] howmany = howmany+1 print(\"arithmetic mean = \",round((accumulator/howmany),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist ! cat data.txt # show contents of the file 'data.txt' on the server 23.43 37.43 34.91 28.37 30.62 xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed that it first appears, but illustrates a five step process (with a refinement step). Throughout the course this process is always in the background. CCMR Approach A lot of the problems we will encounter from a CT/DS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution to your problem from some online example: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like one of the references below, but a URL to the source is sufficient at first. Modify: Modify the original cited work for your specific needs. Note the changes in the code using comment statements. Run: Apply the modified code to the problem of interest. In cases where we apply CCMR we are scaffolding parts (https://en.wikipedia.org/wiki/Scaffold_(programming)) - a legitimate and valuable engineering activity. Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Theodore G. Cleveland, Farhang Forghanparast, Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi. (2021) Computational Thinking and Data Science: A WebBook to Accompany ENGR 1330 at TTU, Whitacre College of Engineering, DOI (pending) https://3.137.111.182/engr-1330-webroot/engr-1330-webbook/ctds-psuedocourse/site/","title":"Problem Solving"},{"location":"1-programming/1-problemsolving/problemsolving/#problem-solving","text":"Copyright \u00a9 2021 Theodore G. Cleveland and Farhang Forghanparast Last GitHub Commit Date: 13 July 2021 a 6-step protocol decomposition ccmr Download this page as a jupyter notebook at http://54.243.252.9/p4e/1-programming/1-problemsolving/problemsolving.ipynb Download the data file referred to herein at http://54.243.252.9/p4e/1-programming/1-problemsolving/data.txt","title":"problem solving"},{"location":"1-programming/1-problemsolving/problemsolving/#computational-thinking-and-problem-solving","text":"Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution. Pattern Recognition refers to finding similarities, or shared characteristics of problems, which allows a complex problem to become easier to solve, and allows use of same solution method for each occurrence of the pattern. Abstraction is the process of identifying important characteristics of the problem and ignore characteristics that are not important. We use these characteristics to create a representation of what we are trying to solve. Algorithms are step-by-step instructions of how to solve a problem System Integration (implementation)is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand.","title":"Computational Thinking and Problem Solving"},{"location":"1-programming/1-problemsolving/problemsolving/#programming-as-a-problem-solving-process","text":"The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method (https://en.wikipedia.org/wiki/Scientific_method) is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4).","title":"Programming as a problem solving process"},{"location":"1-programming/1-problemsolving/problemsolving/#example-1-problem-solving-process","text":"Consider a need to compute an arithmetic mean, what would the process look like? Step 1. Develop script to compute the arithmetic mean of a stream of data of unknown length. Step 2. - Inputs: The data stream - Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. - Outputs: The arithmetic mean \\bar x Step 3. Work a sample problem by-hand for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95 Step 4. Develop a general solution (code) The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. As a recipe (like baking bread) we did the following: Set the sum to zero Set the count to zero Read in the data stream, as each value is read, add it to sum , and increment the count by one when all data are read, compute the mean as: sum/count => result report result Step 5. This step we would code the algorithm expressed in the figure and test it with the by-hand data and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howmany = 0 accumulator = 0 # a variable to accumulate the sum for i in range(len(xlist)): # len is a built-in function that returns how many items in a list accumulator = accumulator + xlist[i] howmany = howmany+1 print(\"arithmetic mean = \",(accumulator/howmany)) arithmetic mean = 30.951999999999998 Step 6. This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howmany = 0 accumulator = 0 # a variable to accumulate the sum for i in range(len(xlist)): # len is a built-in function that returns how many items in a list accumulator = accumulator + xlist[i] howmany = howmany+1 print(\"arithmetic mean = \",round((accumulator/howmany),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist ! cat data.txt # show contents of the file 'data.txt' on the server 23.43 37.43 34.91 28.37 30.62 xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed that it first appears, but illustrates a five step process (with a refinement step). Throughout the course this process is always in the background.","title":"Example 1 Problem Solving Process"},{"location":"1-programming/1-problemsolving/problemsolving/#ccmr-approach","text":"A lot of the problems we will encounter from a CT/DS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution to your problem from some online example: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like one of the references below, but a URL to the source is sufficient at first. Modify: Modify the original cited work for your specific needs. Note the changes in the code using comment statements. Run: Apply the modified code to the problem of interest. In cases where we apply CCMR we are scaffolding parts (https://en.wikipedia.org/wiki/Scaffold_(programming)) - a legitimate and valuable engineering activity.","title":"CCMR Approach"},{"location":"1-programming/1-problemsolving/problemsolving/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Theodore G. Cleveland, Farhang Forghanparast, Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi. (2021) Computational Thinking and Data Science: A WebBook to Accompany ENGR 1330 at TTU, Whitacre College of Engineering, DOI (pending) https://3.137.111.182/engr-1330-webroot/engr-1330-webbook/ctds-psuedocourse/site/","title":"Readings"},{"location":"1-programming/10-selectionstructures/selectionstructures/","text":"Selection Structures Decision making via conditional statements is an important building block in algorithm design; Selection is used to control the flow of execution of a program. Conditional Statements Conditional statements in Python include: if statement if....else statements if....elif....else statements Conditional statements are logical expressions that evaluate as TRUE or FALSE and using these results to perform further operations based on these conditions. Nearly all flow control in a program depends on evaluating conditions. The program will proceed diferently based on the outcome of one or more conditions - really sophisticated AI programs are a collection of conditions and correlations. Expressed in a flowchart a block if statement looks like: As psuedo code: if(condition is true): do stuff Amazon knowing what you want is based on correlations of your past behavior compared to other peoples similar, but more recent behavior, and then it uses conditional statements to decide what item to offer you in your recommendation items. It's a bit spooky, but ultimately just a program running in the background trying to make your money theirs. Comparison The most common conditional operation is comparison. If we wish to compare whether two variables are the same we use the == (double equal sign). For example x == y means the program will ask whether x and y have the same value. If they do, the result is TRUE if not then the result is FALSE. Other comparison signs are != does NOT equal, < smaller than, > larger than, <= less than or equal, and >= greater than or equal. There are also three logical operators when we want to build multiple compares (multiple conditioning); these are and , or , and not . The and operator returns TRUE if (and only if) all conditions are TRUE. For instance 5 == 5 and 5 < 6 will return a TRUE because both conditions are true. The or operator returns TRUE if at least one condition is true. If all conditions are FALSE, then it will return a FALSE. For instance 4 > 3 or 17 > 20 or 3 == 2 will return TRUE because the first condition is true. The not operator returns TRUE if the condition after the not keyword is false. Think of it as a way to do a logic reversal. # Examples Block if statement The if statement is a common flow control statement. It allows the program to evaluate if a certain condition is satisfied and to perform a designed action based on the result of the evaluation. The structure of an if statement is if condition1 is met: do A elif condition 2 is met: do b elif condition 3 is met: do c else: do e The elif means \"else if\". The : colon is an important part of the structure it tells where the action begins. Also there are no scope delimiters like (), or {} . Instead Python uses indentation to isolate blocks of code. This convention is hugely important - many other coding environments use delimiters (called scoping delimiters), but Python does not. The indentation itself is the scoping delimiter. # Examples Inline if statement An inline if statement is a simpler form of an if statement and is more convenient if you only need to perform a simple conditional task. The syntax is: do TaskA `if` condition is true `else` do TaskB An example would be myInt = 3 num1 = 12 if myInt == 0 else 13 print(num1) 13 An alternative way is to enclose the condition in brackets for some clarity like myInt = 3 num1 = 12 if (myInt == 0) else 13 print(num1) 13 In either case the result is that num1 will have the value 13 (unless you set myInt to 0). Example: Light Pipes If light is directed into one end of a long glass or plastic rod the light is totally reflected by the walls bounging until it reaches the end of the rod. Light pipes use this optical phenomenon to transmit light and even images from one place to another. If one bends a light pipe the light can be coaxed to follow the pipe and curve around corners -- if the pipes are bundled into a collection of fibers mutiple signals can be sent down each fiber and these bundles are the main component of optical fiber communication and is schematized in the figure below. The total internal reflection can be predicted using Snell's law and the indices of refraction of the fiber and jacket materials. Usually the core material is selected with a high refractive index compared to the jacket (which may be just air). When light passes from one material to another it is bent at the interface proportional to the refractive indices and the angle of incidence at the interface as in the sketch below The angle of incidence where the light will reflect as opposed to crossing the interface is called the critical angle \\Theta_c and is subject to the formula: sin~\\Theta_c = \\frac{n_2}{n_1} where n_1 is the refractive index of the fiber core and n_2 is the refractive index of the jacket. If the jacket has a higher refractive index than the core, the light pipe will not transmit light from one end to another regardless of the incidence angle. If not, then any incidence angle greater than the critical angle (e.g. closer to the pipe entry axis) will sucessfully achieve internal reflection and transmit. Suppose we wished to make a design tool to let designers evaluate different materials and determine if a particular material selection makes sense, and how small an angle will work (smaller means less precision is required at the entry/exit interface). Lets apply the problem solving protocol, and a bit of computational thinking to develop a tool. Step 1 Problem Statement: Determine whether a light pipe constructed of two materials will transmit light that enters the pipe at a prescribed angle Step 2 Input/Output/Governing Principles Inputs are the indices of refraction of the core ( n_1 ) and jacket( n_2 ) materials and the light incident angle at the pipe entrance ( \\Theta_i ) The governing equations are \\text{If}~\\Theta_i > \\Theta_c~\\text{then light will propagate} and sin~\\Theta_c = \\frac{n_2}{n_1} Step 3 By-Hand Example Consider a core made of optical glass (without coatings) surrounded by air - a pipe without a jacket. The refraction index for air is 1.0003. The index of refraction for glass is 1.52 The critical angle is \\Theta_c = sin^{-1}(\\frac{1.0003}{1.52})= 41.15^o Thus the light pipe will transmit all light that enters at an angle greater than 41.15 degrees. Step 4 Algorithm Development The problem is decomposed as Read into the application the refraction indices n_1 and n_2 and the incidence angle relative to the core/jacket wall. Determine if n_2 is larger than n_1 , if true then no transmission If transmission is possible, then compute critical angle Determine if incident angle larger than critical angle, if true then transmission Report result As psuedocode: prompt user for n1,n2,angle if n2>n1 print no transmission else compute critical angle if incident angle > critical angle then print transmission else print no transmission Below we convert psuedocode to python script # load the math library import math # prompt user for n1,n2,angle print('Begin Light Pipe Design') n1 = float(input('Enter RI of pipe core')) n2 = float(input('Enter RI of pipe jacket')) anglein = float(input('Enter incident angle of light (in degrees)')) # if n2>n1 print no transmission else if (n2>n1): # selection structure print('Light not transmitted, jacket material too dense') else: # compute critical angle critangle = math.degrees(math.asin(n2/n1)) #use math package for arcsine # if incident angle > critical angle then print transmission if anglein > critangle: # selection structure print('Light is transmitted') # else print no transmission else: print('Light is not transmitted, adjust interface angle') print('End Light Pipe Design') Begin Light Pipe Design Enter RI of pipe core 1.52 Enter RI of pipe jacket 1.0003 Enter incident angle of light (in degrees) 45 Light is transmitted End Light Pipe Design Now we have a tool and can evaluate a variety of material pairs to build a light pipe. Material Index of Refraction Hydrogen (1 atm.;0C) 1.0001 Air (1 atm.;0C) 1.0003 Carbon Dioxide(1 atm.;0C) 1.0005 Water (20C) 1.333 Ethanol (20C) 1.362 Glycerine (20C) 1.473 Ice 1.31 Polystryene 1.59 Crown Glass 1.62 Borosilicate 1.75 Carbon (Diamond) 2.417 Acrylic 1.49 Step 5 Testing/Application Apply using acrylic in water # load the math library import math # prompt user for n1,n2,angle print('Begin Light Pipe Design') n1 = float(input('Enter RI of pipe core')) n2 = float(input('Enter RI of pipe jacket')) anglein = float(input('Enter incident angle of light (in degrees)')) # if n2>n1 print no transmission else if (n2>n1): # selection structure print('Light not transmitted, jacket material too dense') else: # compute critical angle critangle = math.degrees(math.asin(n2/n1)) #use math package for arcsine # if incident angle > critical angle then print transmission if anglein > critangle: # selection structure print('Light is transmitted') # else print no transmission else: print('Light is not transmitted, adjust interface angle') print('End Light Pipe Design') Begin Light Pipe Design Enter RI of pipe core 1.49 Enter RI of pipe jacket 1.333 Enter incident angle of light (in degrees) 45 Light is not transmitted, adjust interface angle End Light Pipe Design Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Selection Structures"},{"location":"1-programming/10-selectionstructures/selectionstructures/#selection-structures","text":"Decision making via conditional statements is an important building block in algorithm design; Selection is used to control the flow of execution of a program.","title":"Selection Structures"},{"location":"1-programming/10-selectionstructures/selectionstructures/#conditional-statements","text":"Conditional statements in Python include: if statement if....else statements if....elif....else statements Conditional statements are logical expressions that evaluate as TRUE or FALSE and using these results to perform further operations based on these conditions. Nearly all flow control in a program depends on evaluating conditions. The program will proceed diferently based on the outcome of one or more conditions - really sophisticated AI programs are a collection of conditions and correlations. Expressed in a flowchart a block if statement looks like: As psuedo code: if(condition is true): do stuff Amazon knowing what you want is based on correlations of your past behavior compared to other peoples similar, but more recent behavior, and then it uses conditional statements to decide what item to offer you in your recommendation items. It's a bit spooky, but ultimately just a program running in the background trying to make your money theirs.","title":"Conditional Statements"},{"location":"1-programming/10-selectionstructures/selectionstructures/#comparison","text":"The most common conditional operation is comparison. If we wish to compare whether two variables are the same we use the == (double equal sign). For example x == y means the program will ask whether x and y have the same value. If they do, the result is TRUE if not then the result is FALSE. Other comparison signs are != does NOT equal, < smaller than, > larger than, <= less than or equal, and >= greater than or equal. There are also three logical operators when we want to build multiple compares (multiple conditioning); these are and , or , and not . The and operator returns TRUE if (and only if) all conditions are TRUE. For instance 5 == 5 and 5 < 6 will return a TRUE because both conditions are true. The or operator returns TRUE if at least one condition is true. If all conditions are FALSE, then it will return a FALSE. For instance 4 > 3 or 17 > 20 or 3 == 2 will return TRUE because the first condition is true. The not operator returns TRUE if the condition after the not keyword is false. Think of it as a way to do a logic reversal. # Examples","title":"Comparison"},{"location":"1-programming/10-selectionstructures/selectionstructures/#block-if-statement","text":"The if statement is a common flow control statement. It allows the program to evaluate if a certain condition is satisfied and to perform a designed action based on the result of the evaluation. The structure of an if statement is if condition1 is met: do A elif condition 2 is met: do b elif condition 3 is met: do c else: do e The elif means \"else if\". The : colon is an important part of the structure it tells where the action begins. Also there are no scope delimiters like (), or {} . Instead Python uses indentation to isolate blocks of code. This convention is hugely important - many other coding environments use delimiters (called scoping delimiters), but Python does not. The indentation itself is the scoping delimiter. # Examples","title":"Block if statement"},{"location":"1-programming/10-selectionstructures/selectionstructures/#inline-if-statement","text":"An inline if statement is a simpler form of an if statement and is more convenient if you only need to perform a simple conditional task. The syntax is: do TaskA `if` condition is true `else` do TaskB An example would be myInt = 3 num1 = 12 if myInt == 0 else 13 print(num1) 13 An alternative way is to enclose the condition in brackets for some clarity like myInt = 3 num1 = 12 if (myInt == 0) else 13 print(num1) 13 In either case the result is that num1 will have the value 13 (unless you set myInt to 0).","title":"Inline if statement"},{"location":"1-programming/10-selectionstructures/selectionstructures/#example-light-pipes","text":"If light is directed into one end of a long glass or plastic rod the light is totally reflected by the walls bounging until it reaches the end of the rod. Light pipes use this optical phenomenon to transmit light and even images from one place to another. If one bends a light pipe the light can be coaxed to follow the pipe and curve around corners -- if the pipes are bundled into a collection of fibers mutiple signals can be sent down each fiber and these bundles are the main component of optical fiber communication and is schematized in the figure below. The total internal reflection can be predicted using Snell's law and the indices of refraction of the fiber and jacket materials. Usually the core material is selected with a high refractive index compared to the jacket (which may be just air). When light passes from one material to another it is bent at the interface proportional to the refractive indices and the angle of incidence at the interface as in the sketch below The angle of incidence where the light will reflect as opposed to crossing the interface is called the critical angle \\Theta_c and is subject to the formula: sin~\\Theta_c = \\frac{n_2}{n_1} where n_1 is the refractive index of the fiber core and n_2 is the refractive index of the jacket. If the jacket has a higher refractive index than the core, the light pipe will not transmit light from one end to another regardless of the incidence angle. If not, then any incidence angle greater than the critical angle (e.g. closer to the pipe entry axis) will sucessfully achieve internal reflection and transmit. Suppose we wished to make a design tool to let designers evaluate different materials and determine if a particular material selection makes sense, and how small an angle will work (smaller means less precision is required at the entry/exit interface). Lets apply the problem solving protocol, and a bit of computational thinking to develop a tool. Step 1 Problem Statement: Determine whether a light pipe constructed of two materials will transmit light that enters the pipe at a prescribed angle Step 2 Input/Output/Governing Principles Inputs are the indices of refraction of the core ( n_1 ) and jacket( n_2 ) materials and the light incident angle at the pipe entrance ( \\Theta_i ) The governing equations are \\text{If}~\\Theta_i > \\Theta_c~\\text{then light will propagate} and sin~\\Theta_c = \\frac{n_2}{n_1} Step 3 By-Hand Example Consider a core made of optical glass (without coatings) surrounded by air - a pipe without a jacket. The refraction index for air is 1.0003. The index of refraction for glass is 1.52 The critical angle is \\Theta_c = sin^{-1}(\\frac{1.0003}{1.52})= 41.15^o Thus the light pipe will transmit all light that enters at an angle greater than 41.15 degrees. Step 4 Algorithm Development The problem is decomposed as Read into the application the refraction indices n_1 and n_2 and the incidence angle relative to the core/jacket wall. Determine if n_2 is larger than n_1 , if true then no transmission If transmission is possible, then compute critical angle Determine if incident angle larger than critical angle, if true then transmission Report result As psuedocode: prompt user for n1,n2,angle if n2>n1 print no transmission else compute critical angle if incident angle > critical angle then print transmission else print no transmission Below we convert psuedocode to python script # load the math library import math # prompt user for n1,n2,angle print('Begin Light Pipe Design') n1 = float(input('Enter RI of pipe core')) n2 = float(input('Enter RI of pipe jacket')) anglein = float(input('Enter incident angle of light (in degrees)')) # if n2>n1 print no transmission else if (n2>n1): # selection structure print('Light not transmitted, jacket material too dense') else: # compute critical angle critangle = math.degrees(math.asin(n2/n1)) #use math package for arcsine # if incident angle > critical angle then print transmission if anglein > critangle: # selection structure print('Light is transmitted') # else print no transmission else: print('Light is not transmitted, adjust interface angle') print('End Light Pipe Design') Begin Light Pipe Design Enter RI of pipe core 1.52 Enter RI of pipe jacket 1.0003 Enter incident angle of light (in degrees) 45 Light is transmitted End Light Pipe Design Now we have a tool and can evaluate a variety of material pairs to build a light pipe. Material Index of Refraction Hydrogen (1 atm.;0C) 1.0001 Air (1 atm.;0C) 1.0003 Carbon Dioxide(1 atm.;0C) 1.0005 Water (20C) 1.333 Ethanol (20C) 1.362 Glycerine (20C) 1.473 Ice 1.31 Polystryene 1.59 Crown Glass 1.62 Borosilicate 1.75 Carbon (Diamond) 2.417 Acrylic 1.49 Step 5 Testing/Application Apply using acrylic in water # load the math library import math # prompt user for n1,n2,angle print('Begin Light Pipe Design') n1 = float(input('Enter RI of pipe core')) n2 = float(input('Enter RI of pipe jacket')) anglein = float(input('Enter incident angle of light (in degrees)')) # if n2>n1 print no transmission else if (n2>n1): # selection structure print('Light not transmitted, jacket material too dense') else: # compute critical angle critangle = math.degrees(math.asin(n2/n1)) #use math package for arcsine # if incident angle > critical angle then print transmission if anglein > critangle: # selection structure print('Light is transmitted') # else print no transmission else: print('Light is not transmitted, adjust interface angle') print('End Light Pipe Design') Begin Light Pipe Design Enter RI of pipe core 1.49 Enter RI of pipe jacket 1.333 Enter incident angle of light (in degrees) 45 Light is not transmitted, adjust interface angle End Light Pipe Design","title":"Example: Light Pipes"},{"location":"1-programming/10-selectionstructures/selectionstructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Readings"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/","text":"Repetition Structures The action of doing something over and over again (repetition) is called a loop - the name becomes apparent when we examine a flowchart representation of repetition. Loops repeat a portion of code a finite number of times until a process is complete. Repetitive tasks are very common and essential in programming. They save time in coding, minimize coding errors, and leverage the speed of electronic computation. Loop Analogs If you think any mass manufacturing process, we apply the same process again and again. Even for something very simple such as preparing a peanut butter sandwich: Consider the flowchart in Figure 1, it represents a decomposition of sandwich assembly, but at a high level -- for instance, Gather Ingredients contains a lot of substeps that would need to be decomposed if fully automated assembly were to be accomplished; nevertheless lets stipulate that this flowchart will indeed construct a single sandwich. Figure 1 Supervisory Flowchart Sandwich Assembly (adapted from http://www.str-tn.org/subway_restaurant_training_manual.pdf) If we need to make 1000 peanut butter sandwichs we would then issue a directive to: 1) Implement sandwich assembly, repeat 999 times (repeat is the loop structure) (A serial structure, 1 sandwich artist, doing same job over and over again) OR 2) Implement 1000 sandwich assembly threads (A parallel structure, 1000 sandwich artists doing same job once) In general because we dont want to idle 999 sandwich artists, we would choose the serial structure, which frees 999 people to ask the existential question \"would you like fries with that?\" All cynicism aside, an automated process such as a loop, is typical in computational processing. Aside NVIDIA CUDA, and AMD OpenGL compilers can detect the structure above, and if there are enough GPU threads available , create the 1000 sandwich artists (1000 GPU threads), and run the process in parallel -- the actual workload is unchanged in a thermodynamic sense, but the apparent time (in human terms) spent in sandwich creation is a fraction of the serial approach. This parallelization is called unrolling the loop, and is a pretty common optimization step during compilation. This kind of programming is outside the scope of this class. Main attractiveness of loops is: - Leveraging pattern matching and automation - Code is more organized and shorter,because a loop is a sequence of instructions that is continually repeated until a certain condition is reached. There are 2 main types loops based on the repetition control condition; for loops and while loops. Count controlled repetition for loop structure) Count-controlled repetition is also called definite repetition because the number of repetitions is known before the loop begins executing. When we do not know in advance the number of times we want to execute a statement, we cannot use count-controlled repetition ( while structure discussed later). In such an instance, we would use sentinel-controlled repetition. A count-controlled repetition will exit after running a certain number of times. The count is kept in a variable called an index or counter. When the index reaches a certain value (the loop bound) the loop will end. Count-controlled repetition requires control variable (or loop counter) initial value of the control variable increment (or decrement) by which the control variable is modified each iteration through the loop condition that tests for the final value of the control variable We can use both for and while loops, for count controlled repetition, but the for loop in combination with the range() function is more common. Structured FOR loop We have seen the for loop already, but we will formally introduce it here. The for loop executes a block of code repeatedly until the condition in the for statement is no longer true. Looping through an iterable An iterable is anything that can be looped over - typically a list, string, or tuple. The syntax for looping through an iterable is illustrated by an example. First a generic syntax for a in iterable: print(a) Notice our friends the colon : and the indentation. The range() function to create an iterable The range(begin,end,increment) function will create an iterable starting at a value of begin, in steps defined by increment ( begin += increment ), ending at end . So a generic syntax becomes for a in range(begin,end,increment): print(a) The examples that follow are count-controlled repetition (increment skip if greater) Example for loops # sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): accumulator = accumulator + float(i) print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum from 1 to 9 is 45.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): if i%2 == 0: accumulator = accumulator + float(i) print( 'Sum of Evens from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum of Evens from 1 to 9 is 20.000 howmany = int(input('Enter N')) linetoprint='' for i in range(1,howmany+1,1): linetoprint=linetoprint + '*' print(linetoprint) Enter N 9 * ** *** **** ***** ****** ******* ******** ********* Nested Repetition Nested repetition is when a control structure is placed inside of the body or main part of another control structure. break to exit out of a loop Sometimes you may want to exit the loop when a certain condition different from the counting condition is met. Perhaps you are looping through a list and want to exit when you find the first element in the list that matches some criterion. The break keyword is useful for such an operation. For example run the following program: # j = 0 for i in range(0,9,1): j += 2 print (\"i = \",i,\"j = \",j) if j == 6: break i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 j = 0 for i in range(0,5,1): j += 2 print( \"i = \",i,\"j = \",j) if j == 7: break i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 3 j = 8 i = 4 j = 10 In the first case, the for loop only executes 3 times before the condition j == 6 is TRUE and the loop is exited. In the second case, j == 7 never happens so the loop completes all its anticipated traverses. In both cases an if statement was used within a for loop. Such \"mixed\" control structures are quite common (and pretty necessary). A while loop contained within a for loop, with several if statements would be very common and such a structure is called nested control. There is typically an upper limit to nesting but the limit is pretty large - easily in the hundreds. It depends on the language and the system architecture ; suffice to say it is not a practical limit except possibly for general-domain AI applications. We can also do mundane activities and leverage loops, arithmetic, and format codes to make useful tables like import math # package that contains cosine print(\" Cosines \") print(\" x \",\"|\",\" cos(x) \") print(\"--------|--------\") for i in range(0,157,1): x = float(i)*0.1 print(\"%.3f\" % x, \" |\", \" %.4f \" % math.cos(x)) # note the format code and the placeholder % and syntax Cosines x | cos(x) --------|-------- 0.000 | 1.0000 0.100 | 0.9950 0.200 | 0.9801 0.300 | 0.9553 0.400 | 0.9211 0.500 | 0.8776 0.600 | 0.8253 0.700 | 0.7648 0.800 | 0.6967 0.900 | 0.6216 1.000 | 0.5403 1.100 | 0.4536 1.200 | 0.3624 1.300 | 0.2675 1.400 | 0.1700 1.500 | 0.0707 1.600 | -0.0292 1.700 | -0.1288 1.800 | -0.2272 1.900 | -0.3233 2.000 | -0.4161 2.100 | -0.5048 2.200 | -0.5885 2.300 | -0.6663 2.400 | -0.7374 2.500 | -0.8011 2.600 | -0.8569 2.700 | -0.9041 2.800 | -0.9422 2.900 | -0.9710 3.000 | -0.9900 3.100 | -0.9991 3.200 | -0.9983 3.300 | -0.9875 3.400 | -0.9668 3.500 | -0.9365 3.600 | -0.8968 3.700 | -0.8481 3.800 | -0.7910 3.900 | -0.7259 4.000 | -0.6536 4.100 | -0.5748 4.200 | -0.4903 4.300 | -0.4008 4.400 | -0.3073 4.500 | -0.2108 4.600 | -0.1122 4.700 | -0.0124 4.800 | 0.0875 4.900 | 0.1865 5.000 | 0.2837 5.100 | 0.3780 5.200 | 0.4685 5.300 | 0.5544 5.400 | 0.6347 5.500 | 0.7087 5.600 | 0.7756 5.700 | 0.8347 5.800 | 0.8855 5.900 | 0.9275 6.000 | 0.9602 6.100 | 0.9833 6.200 | 0.9965 6.300 | 0.9999 6.400 | 0.9932 6.500 | 0.9766 6.600 | 0.9502 6.700 | 0.9144 6.800 | 0.8694 6.900 | 0.8157 7.000 | 0.7539 7.100 | 0.6845 7.200 | 0.6084 7.300 | 0.5261 7.400 | 0.4385 7.500 | 0.3466 7.600 | 0.2513 7.700 | 0.1534 7.800 | 0.0540 7.900 | -0.0460 8.000 | -0.1455 8.100 | -0.2435 8.200 | -0.3392 8.300 | -0.4314 8.400 | -0.5193 8.500 | -0.6020 8.600 | -0.6787 8.700 | -0.7486 8.800 | -0.8111 8.900 | -0.8654 9.000 | -0.9111 9.100 | -0.9477 9.200 | -0.9748 9.300 | -0.9922 9.400 | -0.9997 9.500 | -0.9972 9.600 | -0.9847 9.700 | -0.9624 9.800 | -0.9304 9.900 | -0.8892 10.000 | -0.8391 10.100 | -0.7806 10.200 | -0.7143 10.300 | -0.6408 10.400 | -0.5610 10.500 | -0.4755 10.600 | -0.3853 10.700 | -0.2913 10.800 | -0.1943 10.900 | -0.0954 11.000 | 0.0044 11.100 | 0.1042 11.200 | 0.2030 11.300 | 0.2997 11.400 | 0.3935 11.500 | 0.4833 11.600 | 0.5683 11.700 | 0.6476 11.800 | 0.7204 11.900 | 0.7861 12.000 | 0.8439 12.100 | 0.8932 12.200 | 0.9336 12.300 | 0.9647 12.400 | 0.9862 12.500 | 0.9978 12.600 | 0.9994 12.700 | 0.9911 12.800 | 0.9728 12.900 | 0.9449 13.000 | 0.9074 13.100 | 0.8610 13.200 | 0.8059 13.300 | 0.7427 13.400 | 0.6722 13.500 | 0.5949 13.600 | 0.5117 13.700 | 0.4234 13.800 | 0.3308 13.900 | 0.2349 14.000 | 0.1367 14.100 | 0.0372 14.200 | -0.0628 14.300 | -0.1621 14.400 | -0.2598 14.500 | -0.3549 14.600 | -0.4465 14.700 | -0.5336 14.800 | -0.6154 14.900 | -0.6910 15.000 | -0.7597 15.100 | -0.8208 15.200 | -0.8737 15.300 | -0.9179 15.400 | -0.9530 15.500 | -0.9785 15.600 | -0.9942 The continue statement The continue instruction skips the block of code after it is executed for that iteration. It is best illustrated by an example. j = 0 for i in range(0,5,1): j += 2 print (\"\\n i = \", i , \", j = \", j) #here the \\n is a newline command if j == 6: continue print(\" this message will be skipped over if j = 6 \") # still within the loop, so the skip is implemented i = 0 , j = 2 this message will be skipped over if j = 6 i = 1 , j = 4 this message will be skipped over if j = 6 i = 2 , j = 6 i = 3 , j = 8 this message will be skipped over if j = 6 i = 4 , j = 10 this message will be skipped over if j = 6 Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Count Controlled Repetition"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#repetition-structures","text":"The action of doing something over and over again (repetition) is called a loop - the name becomes apparent when we examine a flowchart representation of repetition. Loops repeat a portion of code a finite number of times until a process is complete. Repetitive tasks are very common and essential in programming. They save time in coding, minimize coding errors, and leverage the speed of electronic computation.","title":"Repetition Structures"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#loop-analogs","text":"If you think any mass manufacturing process, we apply the same process again and again. Even for something very simple such as preparing a peanut butter sandwich: Consider the flowchart in Figure 1, it represents a decomposition of sandwich assembly, but at a high level -- for instance, Gather Ingredients contains a lot of substeps that would need to be decomposed if fully automated assembly were to be accomplished; nevertheless lets stipulate that this flowchart will indeed construct a single sandwich. Figure 1 Supervisory Flowchart Sandwich Assembly (adapted from http://www.str-tn.org/subway_restaurant_training_manual.pdf) If we need to make 1000 peanut butter sandwichs we would then issue a directive to: 1) Implement sandwich assembly, repeat 999 times (repeat is the loop structure) (A serial structure, 1 sandwich artist, doing same job over and over again) OR 2) Implement 1000 sandwich assembly threads (A parallel structure, 1000 sandwich artists doing same job once) In general because we dont want to idle 999 sandwich artists, we would choose the serial structure, which frees 999 people to ask the existential question \"would you like fries with that?\" All cynicism aside, an automated process such as a loop, is typical in computational processing. Aside NVIDIA CUDA, and AMD OpenGL compilers can detect the structure above, and if there are enough GPU threads available , create the 1000 sandwich artists (1000 GPU threads), and run the process in parallel -- the actual workload is unchanged in a thermodynamic sense, but the apparent time (in human terms) spent in sandwich creation is a fraction of the serial approach. This parallelization is called unrolling the loop, and is a pretty common optimization step during compilation. This kind of programming is outside the scope of this class. Main attractiveness of loops is: - Leveraging pattern matching and automation - Code is more organized and shorter,because a loop is a sequence of instructions that is continually repeated until a certain condition is reached. There are 2 main types loops based on the repetition control condition; for loops and while loops.","title":"Loop Analogs"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#count-controlled-repetition-for-loop-structure","text":"Count-controlled repetition is also called definite repetition because the number of repetitions is known before the loop begins executing. When we do not know in advance the number of times we want to execute a statement, we cannot use count-controlled repetition ( while structure discussed later). In such an instance, we would use sentinel-controlled repetition. A count-controlled repetition will exit after running a certain number of times. The count is kept in a variable called an index or counter. When the index reaches a certain value (the loop bound) the loop will end. Count-controlled repetition requires control variable (or loop counter) initial value of the control variable increment (or decrement) by which the control variable is modified each iteration through the loop condition that tests for the final value of the control variable We can use both for and while loops, for count controlled repetition, but the for loop in combination with the range() function is more common.","title":"Count controlled repetition for loop structure)"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#structured-for-loop","text":"We have seen the for loop already, but we will formally introduce it here. The for loop executes a block of code repeatedly until the condition in the for statement is no longer true.","title":"Structured FOR loop"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#looping-through-an-iterable","text":"An iterable is anything that can be looped over - typically a list, string, or tuple. The syntax for looping through an iterable is illustrated by an example. First a generic syntax for a in iterable: print(a) Notice our friends the colon : and the indentation.","title":"Looping through an iterable"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#the-range-function-to-create-an-iterable","text":"The range(begin,end,increment) function will create an iterable starting at a value of begin, in steps defined by increment ( begin += increment ), ending at end . So a generic syntax becomes for a in range(begin,end,increment): print(a) The examples that follow are count-controlled repetition (increment skip if greater)","title":"The range() function to create an iterable"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#example-for-loops","text":"# sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): accumulator = accumulator + float(i) print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum from 1 to 9 is 45.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 for i in range(1,howmany+1,1): if i%2 == 0: accumulator = accumulator + float(i) print( 'Sum of Evens from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum of Evens from 1 to 9 is 20.000 howmany = int(input('Enter N')) linetoprint='' for i in range(1,howmany+1,1): linetoprint=linetoprint + '*' print(linetoprint) Enter N 9 * ** *** **** ***** ****** ******* ******** *********","title":"Example for loops"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#nested-repetition","text":"Nested repetition is when a control structure is placed inside of the body or main part of another control structure.","title":"Nested Repetition"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#break-to-exit-out-of-a-loop","text":"Sometimes you may want to exit the loop when a certain condition different from the counting condition is met. Perhaps you are looping through a list and want to exit when you find the first element in the list that matches some criterion. The break keyword is useful for such an operation. For example run the following program: # j = 0 for i in range(0,9,1): j += 2 print (\"i = \",i,\"j = \",j) if j == 6: break i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 j = 0 for i in range(0,5,1): j += 2 print( \"i = \",i,\"j = \",j) if j == 7: break i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 3 j = 8 i = 4 j = 10 In the first case, the for loop only executes 3 times before the condition j == 6 is TRUE and the loop is exited. In the second case, j == 7 never happens so the loop completes all its anticipated traverses. In both cases an if statement was used within a for loop. Such \"mixed\" control structures are quite common (and pretty necessary). A while loop contained within a for loop, with several if statements would be very common and such a structure is called nested control. There is typically an upper limit to nesting but the limit is pretty large - easily in the hundreds. It depends on the language and the system architecture ; suffice to say it is not a practical limit except possibly for general-domain AI applications. We can also do mundane activities and leverage loops, arithmetic, and format codes to make useful tables like import math # package that contains cosine print(\" Cosines \") print(\" x \",\"|\",\" cos(x) \") print(\"--------|--------\") for i in range(0,157,1): x = float(i)*0.1 print(\"%.3f\" % x, \" |\", \" %.4f \" % math.cos(x)) # note the format code and the placeholder % and syntax Cosines x | cos(x) --------|-------- 0.000 | 1.0000 0.100 | 0.9950 0.200 | 0.9801 0.300 | 0.9553 0.400 | 0.9211 0.500 | 0.8776 0.600 | 0.8253 0.700 | 0.7648 0.800 | 0.6967 0.900 | 0.6216 1.000 | 0.5403 1.100 | 0.4536 1.200 | 0.3624 1.300 | 0.2675 1.400 | 0.1700 1.500 | 0.0707 1.600 | -0.0292 1.700 | -0.1288 1.800 | -0.2272 1.900 | -0.3233 2.000 | -0.4161 2.100 | -0.5048 2.200 | -0.5885 2.300 | -0.6663 2.400 | -0.7374 2.500 | -0.8011 2.600 | -0.8569 2.700 | -0.9041 2.800 | -0.9422 2.900 | -0.9710 3.000 | -0.9900 3.100 | -0.9991 3.200 | -0.9983 3.300 | -0.9875 3.400 | -0.9668 3.500 | -0.9365 3.600 | -0.8968 3.700 | -0.8481 3.800 | -0.7910 3.900 | -0.7259 4.000 | -0.6536 4.100 | -0.5748 4.200 | -0.4903 4.300 | -0.4008 4.400 | -0.3073 4.500 | -0.2108 4.600 | -0.1122 4.700 | -0.0124 4.800 | 0.0875 4.900 | 0.1865 5.000 | 0.2837 5.100 | 0.3780 5.200 | 0.4685 5.300 | 0.5544 5.400 | 0.6347 5.500 | 0.7087 5.600 | 0.7756 5.700 | 0.8347 5.800 | 0.8855 5.900 | 0.9275 6.000 | 0.9602 6.100 | 0.9833 6.200 | 0.9965 6.300 | 0.9999 6.400 | 0.9932 6.500 | 0.9766 6.600 | 0.9502 6.700 | 0.9144 6.800 | 0.8694 6.900 | 0.8157 7.000 | 0.7539 7.100 | 0.6845 7.200 | 0.6084 7.300 | 0.5261 7.400 | 0.4385 7.500 | 0.3466 7.600 | 0.2513 7.700 | 0.1534 7.800 | 0.0540 7.900 | -0.0460 8.000 | -0.1455 8.100 | -0.2435 8.200 | -0.3392 8.300 | -0.4314 8.400 | -0.5193 8.500 | -0.6020 8.600 | -0.6787 8.700 | -0.7486 8.800 | -0.8111 8.900 | -0.8654 9.000 | -0.9111 9.100 | -0.9477 9.200 | -0.9748 9.300 | -0.9922 9.400 | -0.9997 9.500 | -0.9972 9.600 | -0.9847 9.700 | -0.9624 9.800 | -0.9304 9.900 | -0.8892 10.000 | -0.8391 10.100 | -0.7806 10.200 | -0.7143 10.300 | -0.6408 10.400 | -0.5610 10.500 | -0.4755 10.600 | -0.3853 10.700 | -0.2913 10.800 | -0.1943 10.900 | -0.0954 11.000 | 0.0044 11.100 | 0.1042 11.200 | 0.2030 11.300 | 0.2997 11.400 | 0.3935 11.500 | 0.4833 11.600 | 0.5683 11.700 | 0.6476 11.800 | 0.7204 11.900 | 0.7861 12.000 | 0.8439 12.100 | 0.8932 12.200 | 0.9336 12.300 | 0.9647 12.400 | 0.9862 12.500 | 0.9978 12.600 | 0.9994 12.700 | 0.9911 12.800 | 0.9728 12.900 | 0.9449 13.000 | 0.9074 13.100 | 0.8610 13.200 | 0.8059 13.300 | 0.7427 13.400 | 0.6722 13.500 | 0.5949 13.600 | 0.5117 13.700 | 0.4234 13.800 | 0.3308 13.900 | 0.2349 14.000 | 0.1367 14.100 | 0.0372 14.200 | -0.0628 14.300 | -0.1621 14.400 | -0.2598 14.500 | -0.3549 14.600 | -0.4465 14.700 | -0.5336 14.800 | -0.6154 14.900 | -0.6910 15.000 | -0.7597 15.100 | -0.8208 15.200 | -0.8737 15.300 | -0.9179 15.400 | -0.9530 15.500 | -0.9785 15.600 | -0.9942","title":"break to exit out of a loop"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#the-continue-statement","text":"The continue instruction skips the block of code after it is executed for that iteration. It is best illustrated by an example. j = 0 for i in range(0,5,1): j += 2 print (\"\\n i = \", i , \", j = \", j) #here the \\n is a newline command if j == 6: continue print(\" this message will be skipped over if j = 6 \") # still within the loop, so the skip is implemented i = 0 , j = 2 this message will be skipped over if j = 6 i = 1 , j = 4 this message will be skipped over if j = 6 i = 2 , j = 6 i = 3 , j = 8 this message will be skipped over if j = 6 i = 4 , j = 10 this message will be skipped over if j = 6","title":"The continue statement"},{"location":"1-programming/11-repetitionstructures/ccrepetitionstructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Readings"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/","text":"Sentinel-controlled repetition. When loop control is based on the value of what we are processing, sentinel-controlled repetition is used. Sentinel-controlled repetition is also called indefinite repetition because it is not known in advance how many times the loop will be executed. It is a repetition procedure for solving a problem by using a sentinel value (also called a signal value, a dummy value or a flag value) to indicate \"end of process\". The sentinel value itself need not be a part of the processed data. One common example of using sentinel-controlled repetition is when we are processing data from a file and we do not know in advance when we would reach the end of the file. We can use both for and while loops, for Sentinel controlled repetition, but the while loop is more common. Structured WHILE loop The while loop repeats a block of instructions inside the loop while a condition remainsvtrue. First a generic syntax while condition is true: execute a execute b .... Notice our friends the colon : and the indentation again. Example while loops # sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: accumulator = accumulator + float(counter) counter += 1 print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum from 1 to 9 is 45.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: if counter%2 == 0: accumulator = accumulator + float(counter) counter += 1 print( 'Sum of Evens 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum of Evens 1 to 9 is 20.000 howmany = int(input('Enter N')) linetoprint='' counter = 1 while counter <= howmany: linetoprint=linetoprint + '*' counter += 1 print(linetoprint) Enter N 9 * ** *** **** ***** ****** ******* ******** ********* Nested Repetition Nested repetition is when a control structure is placed inside of the body or main part of another control structure. break to exit out of a loop Sometimes you may want to exit the loop when a certain condition different from the counting condition is met. Perhaps you are looping through a list and want to exit when you find the first element in the list that matches some criterion. The break keyword is useful for such an operation. For example run the following program: # i = 0 j = 0 while i < 9: j += 2 print (\"i = \",i,\"j = \",j) if j == 6: break i = i + 1 i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 0 j = 0 while i <5 : j += 2 print( \"i = \",i,\"j = \",j) if j == 7: break i = i + 1 i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 3 j = 8 i = 4 j = 10 In the first case, the while loop only executes 3 times before the condition j == 6 is TRUE and the loop is exited. In the second case, j == 7 never happens so the loop completes all its anticipated traverses. In both cases an if statement was used within a for loop. Such \"mixed\" control structures are quite common (and pretty necessary). A while loop contained within a for loop, with several if statements would be very common and such a structure is called nested control. There is typically an upper limit to nesting but the limit is pretty large - easily in the hundreds. It depends on the language and the system architecture ; suffice to say it is not a practical limit except possibly for general-domain AI applications. We can also do mundane activities and leverage loops, arithmetic, and format codes to make useful tables like import math # package that contains cosine print(\" Cosines \") print(\" x \",\"|\",\" cos(x) \") print(\"--------|--------\") i = 0 while i < 157: x = float(i)*0.1 print(\"%.3f\" % x, \" |\", \" %.4f \" % math.cos(x)) # note the format code and the placeholder % and syntax i = i + 1 Cosines x | cos(x) --------|-------- 0.000 | 1.0000 0.100 | 0.9950 0.200 | 0.9801 0.300 | 0.9553 0.400 | 0.9211 0.500 | 0.8776 0.600 | 0.8253 0.700 | 0.7648 0.800 | 0.6967 0.900 | 0.6216 1.000 | 0.5403 1.100 | 0.4536 1.200 | 0.3624 1.300 | 0.2675 1.400 | 0.1700 1.500 | 0.0707 1.600 | -0.0292 1.700 | -0.1288 1.800 | -0.2272 1.900 | -0.3233 2.000 | -0.4161 2.100 | -0.5048 2.200 | -0.5885 2.300 | -0.6663 2.400 | -0.7374 2.500 | -0.8011 2.600 | -0.8569 2.700 | -0.9041 2.800 | -0.9422 2.900 | -0.9710 3.000 | -0.9900 3.100 | -0.9991 3.200 | -0.9983 3.300 | -0.9875 3.400 | -0.9668 3.500 | -0.9365 3.600 | -0.8968 3.700 | -0.8481 3.800 | -0.7910 3.900 | -0.7259 4.000 | -0.6536 4.100 | -0.5748 4.200 | -0.4903 4.300 | -0.4008 4.400 | -0.3073 4.500 | -0.2108 4.600 | -0.1122 4.700 | -0.0124 4.800 | 0.0875 4.900 | 0.1865 5.000 | 0.2837 5.100 | 0.3780 5.200 | 0.4685 5.300 | 0.5544 5.400 | 0.6347 5.500 | 0.7087 5.600 | 0.7756 5.700 | 0.8347 5.800 | 0.8855 5.900 | 0.9275 6.000 | 0.9602 6.100 | 0.9833 6.200 | 0.9965 6.300 | 0.9999 6.400 | 0.9932 6.500 | 0.9766 6.600 | 0.9502 6.700 | 0.9144 6.800 | 0.8694 6.900 | 0.8157 7.000 | 0.7539 7.100 | 0.6845 7.200 | 0.6084 7.300 | 0.5261 7.400 | 0.4385 7.500 | 0.3466 7.600 | 0.2513 7.700 | 0.1534 7.800 | 0.0540 7.900 | -0.0460 8.000 | -0.1455 8.100 | -0.2435 8.200 | -0.3392 8.300 | -0.4314 8.400 | -0.5193 8.500 | -0.6020 8.600 | -0.6787 8.700 | -0.7486 8.800 | -0.8111 8.900 | -0.8654 9.000 | -0.9111 9.100 | -0.9477 9.200 | -0.9748 9.300 | -0.9922 9.400 | -0.9997 9.500 | -0.9972 9.600 | -0.9847 9.700 | -0.9624 9.800 | -0.9304 9.900 | -0.8892 10.000 | -0.8391 10.100 | -0.7806 10.200 | -0.7143 10.300 | -0.6408 10.400 | -0.5610 10.500 | -0.4755 10.600 | -0.3853 10.700 | -0.2913 10.800 | -0.1943 10.900 | -0.0954 11.000 | 0.0044 11.100 | 0.1042 11.200 | 0.2030 11.300 | 0.2997 11.400 | 0.3935 11.500 | 0.4833 11.600 | 0.5683 11.700 | 0.6476 11.800 | 0.7204 11.900 | 0.7861 12.000 | 0.8439 12.100 | 0.8932 12.200 | 0.9336 12.300 | 0.9647 12.400 | 0.9862 12.500 | 0.9978 12.600 | 0.9994 12.700 | 0.9911 12.800 | 0.9728 12.900 | 0.9449 13.000 | 0.9074 13.100 | 0.8610 13.200 | 0.8059 13.300 | 0.7427 13.400 | 0.6722 13.500 | 0.5949 13.600 | 0.5117 13.700 | 0.4234 13.800 | 0.3308 13.900 | 0.2349 14.000 | 0.1367 14.100 | 0.0372 14.200 | -0.0628 14.300 | -0.1621 14.400 | -0.2598 14.500 | -0.3549 14.600 | -0.4465 14.700 | -0.5336 14.800 | -0.6154 14.900 | -0.6910 15.000 | -0.7597 15.100 | -0.8208 15.200 | -0.8737 15.300 | -0.9179 15.400 | -0.9530 15.500 | -0.9785 15.600 | -0.9942 The continue statement The continue instruction skips the block of code after it is executed for that iteration. It is best illustrated by an example. i = 0 j = 0 while i < 5: j += 2 print (\"\\n i = \", i , \", j = \", j) #here the \\n is a newline command if j == 6: continue print(\" this message will be skipped over if j = 6 \") # still within the loop, so the skip is implemented i = i + 1 i = 0 , j = 2 this message will be skipped over if j = 6 i = 1 , j = 4 this message will be skipped over if j = 6 i = 2 , j = 6 i = 2 , j = 8 this message will be skipped over if j = 6 i = 3 , j = 10 this message will be skipped over if j = 6 i = 4 , j = 12 this message will be skipped over if j = 6 The try , except structure An important control structure (and a pretty cool one for error trapping) is the try , except statement. The statement controls how the program proceeds when an error occurs in an instruction. The structure is really useful to trap likely errors (divide by zero, wrong kind of input) yet let the program keep running or at least issue a meaningful message to the user. The syntax is: try: do something except: do something else if ``do something'' returns an error Here is a really simple, but hugely important example: #MyErrorTrap.py x = 12. y = 12. while y >= -12.: # sentinel controlled repetition try: print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) except: print (\"error divide by zero\") y -= 1 x = 12.0 y = 12.0 x/y = 1.0 x = 12.0 y = 11.0 x/y = 1.0909090909090908 x = 12.0 y = 10.0 x/y = 1.2 x = 12.0 y = 9.0 x/y = 1.3333333333333333 x = 12.0 y = 8.0 x/y = 1.5 x = 12.0 y = 7.0 x/y = 1.7142857142857142 x = 12.0 y = 6.0 x/y = 2.0 x = 12.0 y = 5.0 x/y = 2.4 x = 12.0 y = 4.0 x/y = 3.0 x = 12.0 y = 3.0 x/y = 4.0 x = 12.0 y = 2.0 x/y = 6.0 x = 12.0 y = 1.0 x/y = 12.0 error divide by zero x = 12.0 y = -1.0 x/y = -12.0 x = 12.0 y = -2.0 x/y = -6.0 x = 12.0 y = -3.0 x/y = -4.0 x = 12.0 y = -4.0 x/y = -3.0 x = 12.0 y = -5.0 x/y = -2.4 x = 12.0 y = -6.0 x/y = -2.0 x = 12.0 y = -7.0 x/y = -1.7142857142857142 x = 12.0 y = -8.0 x/y = -1.5 x = 12.0 y = -9.0 x/y = -1.3333333333333333 x = 12.0 y = -10.0 x/y = -1.2 x = 12.0 y = -11.0 x/y = -1.0909090909090908 x = 12.0 y = -12.0 x/y = -1.0 So this silly code starts with x fixed at a value of 12, and y starting at 12 and decreasing by 1 until y equals -1. The code returns the ratio of x to y and at one point y is equal to zero and the division would be undefined. By trapping the error the code can issue us a measure and keep running. Modify the script as shown below,Run, and see what happens #NoErrorTrap.py x = 12. y = 12. while y >= -12.: # sentinel controlled repetition print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) y -= 1 x = 12.0 y = 12.0 x/y = 1.0 x = 12.0 y = 11.0 x/y = 1.0909090909090908 x = 12.0 y = 10.0 x/y = 1.2 x = 12.0 y = 9.0 x/y = 1.3333333333333333 x = 12.0 y = 8.0 x/y = 1.5 x = 12.0 y = 7.0 x/y = 1.7142857142857142 x = 12.0 y = 6.0 x/y = 2.0 x = 12.0 y = 5.0 x/y = 2.4 x = 12.0 y = 4.0 x/y = 3.0 x = 12.0 y = 3.0 x/y = 4.0 x = 12.0 y = 2.0 x/y = 6.0 x = 12.0 y = 1.0 x/y = 12.0 --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-5-82eeaceb9a12> in <module> 3 y = 12. 4 while y >= -12.: # sentinel controlled repetition ----> 5 print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) 6 y -= 1 ZeroDivisionError: float division by zero Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Sentinel Controlled Repetition"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#sentinel-controlled-repetition","text":"When loop control is based on the value of what we are processing, sentinel-controlled repetition is used. Sentinel-controlled repetition is also called indefinite repetition because it is not known in advance how many times the loop will be executed. It is a repetition procedure for solving a problem by using a sentinel value (also called a signal value, a dummy value or a flag value) to indicate \"end of process\". The sentinel value itself need not be a part of the processed data. One common example of using sentinel-controlled repetition is when we are processing data from a file and we do not know in advance when we would reach the end of the file. We can use both for and while loops, for Sentinel controlled repetition, but the while loop is more common.","title":"Sentinel-controlled repetition."},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#structured-while-loop","text":"The while loop repeats a block of instructions inside the loop while a condition remainsvtrue. First a generic syntax while condition is true: execute a execute b .... Notice our friends the colon : and the indentation again.","title":"Structured WHILE loop"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#example-while-loops","text":"# sum numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: accumulator = accumulator + float(counter) counter += 1 print( 'Sum from 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum from 1 to 9 is 45.000 # sum even numbers from 1 to n howmany = int(input('Enter N')) accumulator = 0.0 counter = 1 while counter <= howmany: if counter%2 == 0: accumulator = accumulator + float(counter) counter += 1 print( 'Sum of Evens 1 to ',howmany, 'is %.3f' % accumulator ) Enter N 9 Sum of Evens 1 to 9 is 20.000 howmany = int(input('Enter N')) linetoprint='' counter = 1 while counter <= howmany: linetoprint=linetoprint + '*' counter += 1 print(linetoprint) Enter N 9 * ** *** **** ***** ****** ******* ******** *********","title":"Example while loops"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#nested-repetition","text":"Nested repetition is when a control structure is placed inside of the body or main part of another control structure.","title":"Nested Repetition"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#break-to-exit-out-of-a-loop","text":"Sometimes you may want to exit the loop when a certain condition different from the counting condition is met. Perhaps you are looping through a list and want to exit when you find the first element in the list that matches some criterion. The break keyword is useful for such an operation. For example run the following program: # i = 0 j = 0 while i < 9: j += 2 print (\"i = \",i,\"j = \",j) if j == 6: break i = i + 1 i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 0 j = 0 while i <5 : j += 2 print( \"i = \",i,\"j = \",j) if j == 7: break i = i + 1 i = 0 j = 2 i = 1 j = 4 i = 2 j = 6 i = 3 j = 8 i = 4 j = 10 In the first case, the while loop only executes 3 times before the condition j == 6 is TRUE and the loop is exited. In the second case, j == 7 never happens so the loop completes all its anticipated traverses. In both cases an if statement was used within a for loop. Such \"mixed\" control structures are quite common (and pretty necessary). A while loop contained within a for loop, with several if statements would be very common and such a structure is called nested control. There is typically an upper limit to nesting but the limit is pretty large - easily in the hundreds. It depends on the language and the system architecture ; suffice to say it is not a practical limit except possibly for general-domain AI applications. We can also do mundane activities and leverage loops, arithmetic, and format codes to make useful tables like import math # package that contains cosine print(\" Cosines \") print(\" x \",\"|\",\" cos(x) \") print(\"--------|--------\") i = 0 while i < 157: x = float(i)*0.1 print(\"%.3f\" % x, \" |\", \" %.4f \" % math.cos(x)) # note the format code and the placeholder % and syntax i = i + 1 Cosines x | cos(x) --------|-------- 0.000 | 1.0000 0.100 | 0.9950 0.200 | 0.9801 0.300 | 0.9553 0.400 | 0.9211 0.500 | 0.8776 0.600 | 0.8253 0.700 | 0.7648 0.800 | 0.6967 0.900 | 0.6216 1.000 | 0.5403 1.100 | 0.4536 1.200 | 0.3624 1.300 | 0.2675 1.400 | 0.1700 1.500 | 0.0707 1.600 | -0.0292 1.700 | -0.1288 1.800 | -0.2272 1.900 | -0.3233 2.000 | -0.4161 2.100 | -0.5048 2.200 | -0.5885 2.300 | -0.6663 2.400 | -0.7374 2.500 | -0.8011 2.600 | -0.8569 2.700 | -0.9041 2.800 | -0.9422 2.900 | -0.9710 3.000 | -0.9900 3.100 | -0.9991 3.200 | -0.9983 3.300 | -0.9875 3.400 | -0.9668 3.500 | -0.9365 3.600 | -0.8968 3.700 | -0.8481 3.800 | -0.7910 3.900 | -0.7259 4.000 | -0.6536 4.100 | -0.5748 4.200 | -0.4903 4.300 | -0.4008 4.400 | -0.3073 4.500 | -0.2108 4.600 | -0.1122 4.700 | -0.0124 4.800 | 0.0875 4.900 | 0.1865 5.000 | 0.2837 5.100 | 0.3780 5.200 | 0.4685 5.300 | 0.5544 5.400 | 0.6347 5.500 | 0.7087 5.600 | 0.7756 5.700 | 0.8347 5.800 | 0.8855 5.900 | 0.9275 6.000 | 0.9602 6.100 | 0.9833 6.200 | 0.9965 6.300 | 0.9999 6.400 | 0.9932 6.500 | 0.9766 6.600 | 0.9502 6.700 | 0.9144 6.800 | 0.8694 6.900 | 0.8157 7.000 | 0.7539 7.100 | 0.6845 7.200 | 0.6084 7.300 | 0.5261 7.400 | 0.4385 7.500 | 0.3466 7.600 | 0.2513 7.700 | 0.1534 7.800 | 0.0540 7.900 | -0.0460 8.000 | -0.1455 8.100 | -0.2435 8.200 | -0.3392 8.300 | -0.4314 8.400 | -0.5193 8.500 | -0.6020 8.600 | -0.6787 8.700 | -0.7486 8.800 | -0.8111 8.900 | -0.8654 9.000 | -0.9111 9.100 | -0.9477 9.200 | -0.9748 9.300 | -0.9922 9.400 | -0.9997 9.500 | -0.9972 9.600 | -0.9847 9.700 | -0.9624 9.800 | -0.9304 9.900 | -0.8892 10.000 | -0.8391 10.100 | -0.7806 10.200 | -0.7143 10.300 | -0.6408 10.400 | -0.5610 10.500 | -0.4755 10.600 | -0.3853 10.700 | -0.2913 10.800 | -0.1943 10.900 | -0.0954 11.000 | 0.0044 11.100 | 0.1042 11.200 | 0.2030 11.300 | 0.2997 11.400 | 0.3935 11.500 | 0.4833 11.600 | 0.5683 11.700 | 0.6476 11.800 | 0.7204 11.900 | 0.7861 12.000 | 0.8439 12.100 | 0.8932 12.200 | 0.9336 12.300 | 0.9647 12.400 | 0.9862 12.500 | 0.9978 12.600 | 0.9994 12.700 | 0.9911 12.800 | 0.9728 12.900 | 0.9449 13.000 | 0.9074 13.100 | 0.8610 13.200 | 0.8059 13.300 | 0.7427 13.400 | 0.6722 13.500 | 0.5949 13.600 | 0.5117 13.700 | 0.4234 13.800 | 0.3308 13.900 | 0.2349 14.000 | 0.1367 14.100 | 0.0372 14.200 | -0.0628 14.300 | -0.1621 14.400 | -0.2598 14.500 | -0.3549 14.600 | -0.4465 14.700 | -0.5336 14.800 | -0.6154 14.900 | -0.6910 15.000 | -0.7597 15.100 | -0.8208 15.200 | -0.8737 15.300 | -0.9179 15.400 | -0.9530 15.500 | -0.9785 15.600 | -0.9942","title":"break to exit out of a loop"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#the-continue-statement","text":"The continue instruction skips the block of code after it is executed for that iteration. It is best illustrated by an example. i = 0 j = 0 while i < 5: j += 2 print (\"\\n i = \", i , \", j = \", j) #here the \\n is a newline command if j == 6: continue print(\" this message will be skipped over if j = 6 \") # still within the loop, so the skip is implemented i = i + 1 i = 0 , j = 2 this message will be skipped over if j = 6 i = 1 , j = 4 this message will be skipped over if j = 6 i = 2 , j = 6 i = 2 , j = 8 this message will be skipped over if j = 6 i = 3 , j = 10 this message will be skipped over if j = 6 i = 4 , j = 12 this message will be skipped over if j = 6","title":"The continue statement"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#the-try-except-structure","text":"An important control structure (and a pretty cool one for error trapping) is the try , except statement. The statement controls how the program proceeds when an error occurs in an instruction. The structure is really useful to trap likely errors (divide by zero, wrong kind of input) yet let the program keep running or at least issue a meaningful message to the user. The syntax is: try: do something except: do something else if ``do something'' returns an error Here is a really simple, but hugely important example: #MyErrorTrap.py x = 12. y = 12. while y >= -12.: # sentinel controlled repetition try: print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) except: print (\"error divide by zero\") y -= 1 x = 12.0 y = 12.0 x/y = 1.0 x = 12.0 y = 11.0 x/y = 1.0909090909090908 x = 12.0 y = 10.0 x/y = 1.2 x = 12.0 y = 9.0 x/y = 1.3333333333333333 x = 12.0 y = 8.0 x/y = 1.5 x = 12.0 y = 7.0 x/y = 1.7142857142857142 x = 12.0 y = 6.0 x/y = 2.0 x = 12.0 y = 5.0 x/y = 2.4 x = 12.0 y = 4.0 x/y = 3.0 x = 12.0 y = 3.0 x/y = 4.0 x = 12.0 y = 2.0 x/y = 6.0 x = 12.0 y = 1.0 x/y = 12.0 error divide by zero x = 12.0 y = -1.0 x/y = -12.0 x = 12.0 y = -2.0 x/y = -6.0 x = 12.0 y = -3.0 x/y = -4.0 x = 12.0 y = -4.0 x/y = -3.0 x = 12.0 y = -5.0 x/y = -2.4 x = 12.0 y = -6.0 x/y = -2.0 x = 12.0 y = -7.0 x/y = -1.7142857142857142 x = 12.0 y = -8.0 x/y = -1.5 x = 12.0 y = -9.0 x/y = -1.3333333333333333 x = 12.0 y = -10.0 x/y = -1.2 x = 12.0 y = -11.0 x/y = -1.0909090909090908 x = 12.0 y = -12.0 x/y = -1.0 So this silly code starts with x fixed at a value of 12, and y starting at 12 and decreasing by 1 until y equals -1. The code returns the ratio of x to y and at one point y is equal to zero and the division would be undefined. By trapping the error the code can issue us a measure and keep running. Modify the script as shown below,Run, and see what happens #NoErrorTrap.py x = 12. y = 12. while y >= -12.: # sentinel controlled repetition print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) y -= 1 x = 12.0 y = 12.0 x/y = 1.0 x = 12.0 y = 11.0 x/y = 1.0909090909090908 x = 12.0 y = 10.0 x/y = 1.2 x = 12.0 y = 9.0 x/y = 1.3333333333333333 x = 12.0 y = 8.0 x/y = 1.5 x = 12.0 y = 7.0 x/y = 1.7142857142857142 x = 12.0 y = 6.0 x/y = 2.0 x = 12.0 y = 5.0 x/y = 2.4 x = 12.0 y = 4.0 x/y = 3.0 x = 12.0 y = 3.0 x/y = 4.0 x = 12.0 y = 2.0 x/y = 6.0 x = 12.0 y = 1.0 x/y = 12.0 --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) <ipython-input-5-82eeaceb9a12> in <module> 3 y = 12. 4 while y >= -12.: # sentinel controlled repetition ----> 5 print (\"x = \", x, \"y = \", y, \"x/y = \", x/y) 6 y -= 1 ZeroDivisionError: float division by zero","title":"The try, except structure"},{"location":"1-programming/11-repetitionstructures/screpetitionstructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Readings"},{"location":"1-programming/13-functions/functions/","text":"Function Functions are simply pre-written code fragments that perform a certain task. In older procedural languages functions and subroutines are similar, but a function returns a value whereas a subroutine operates on data. The difference is subtle but important. More recent thinking has functions being able to operate on data (they always could) and the value returned may be simply an exit code. An analogy are the functions in MS Excel . To add numbers, we can use the sum(range) function and type =sum(A1:A5) instead of typing =A1+A2+A3+A4+A5 Calling the Function We call a function simply by typing the name of the function or by using the dot notation. Whether we can use the dot notation or not depends on how the function is written, whether it is part of a class, and how it is imported into a program. Some functions expect us to pass data to them to perform their tasks. These data are known as parameters( older terminology is arguments, or argument list) and we pass them to the function by enclosing their values in parenthesis ( ) separated by commas. For instance, the print() function for displaying text on the screen is \\called\" by typing print('Hello World') where print is the name of the function and the literal (a string) 'Hello World' is the argument. Program flow A function, whether built-in, or added must be defined before it is called, otherwise the script will fail. Certain built-in functions \"self define\" upon start (such as print() and type() and we need not worry about those funtions). The diagram below illustrates the requesite flow control for functions that need to be defined before use. An example below will illustrate, change the cell to code and run it, you should get an error. Then fix the indicated line (remove the leading \"#\" in the import math ... line) and rerun, should get a functioning script. # reset the notebook using a magic function in JupyterLab %reset -f # An example, run once as is then activate indicated line, run again - what happens? x= 4. sqrt_by_arithmetic = x**0.5 print('Using arithmetic square root of ', x, ' is ',sqrt_by_arithmetic ) import math # import the math package ## activate and rerun sqrt_by_math = math.sqrt(x) # note the dot notation print('Using math package square root of ', x,' is ',sqrt_by_arithmetic) Using arithmetic square root of 4.0 is 2.0 Using math package square root of 4.0 is 2.0 An alternate way to load just the sqrt() function is shown below, either way is fine. # reset the notebook using a magic function in JupyterLab %reset -f # An example, run once as is then activate indicated line, run again - what happens? x= 4. sqrt_by_arithmetic = x**0.5 print('Using arithmetic square root of ', x, ' is ',sqrt_by_arithmetic ) from math import sqrt # import sqrt from the math package ## activate and rerun sqrt_by_math = sqrt(x) # note the notation print('Using math package square root of ', x,' is ',sqrt_by_arithmetic) Using arithmetic square root of 4.0 is 2.0 Using math package square root of 4.0 is 2.0 Intrinsic (Built-in) in Base Python The base Python functions and types built into it that are always available, the figure below lists those functions. Notice all have the structure of function_name() , except __import__() which has a constructor type structure, and is not intended for routine use. We will learn about constructors later. Using External Packages/Modules and Libaries (e.g. math) Python is also distributed with a large number of external functions. These functions are saved in files known as modules. To use the built-in codes in Python modules, we have to import them into our programs first. We do that by using the import keyword. There are three ways to import: Import the entire module by writing import moduleName; For instance, to import the random module, we write import random. To use the randrange() function in the random module, we write random.randrange( 1, 10);28 Import and rename the module by writing import random as r (where r is any name of your choice). Now to use the randrange() function, you simply write r.randrange(1, 10); and Import specific functions from the module by writing from moduleName import name1[,name2[, ... nameN]]. For instance, to import the randrange() function from the random module, we write from random import randrange. To import multiple functions, we separate them with a comma. To import the randrange() and randint() functions, we write from random import randrange, randint. To use the function now, we do not have to use the dot notation anymore. Just write randrange( 1, 10). A couple of usually available modules that install with base python are math and array . Other modules we will use may need a separate system install (using pip or conda) are numpy , pandas , and matplotlib . This notebook is created on a Raspberry Pi running a JupyterHub server, so these modules are installed using pip. If you build your environment using Anaconda, these modules should be available simply via import . # Example 1 of import %reset -f import random low = 1 ; high = 10 random.randrange(low,high) #generate random number in range low to high 3 # Example 2 of import %reset -f import random as r #the alias r replaces random in subsequent calls low = 1 ; high = 10 r.randrange(low,high) 7 # Example 3 of import %reset -f from random import randrange # importing a single function from a module low = 1 ; high = 10 randrange(low,high) 6 The modules that come with Python are extensive and listed at https://docs.python.org/3/py-modindex.html. There are also other modules that can be downloaded and used (just like user defined modules below). In these labs we are building primitive codes to learn how to code and how to create algorithms. For many practical cases you will want to load a well-tested package to accomplish the tasks. User-Built We can define our own functions in Python and reuse them throughout the program. The syntax for defining a function is (the fragment below is psuedocode - it won't cut and paste!): def functionName( argument ): code detailing what the function should do note the colon above and indentation ... ... return [expression] The keyword def tells the program that the indented code from the next line onwards is part of the function. The keyword return tells the program to return an answer from the function. There can be multiple return statements in a function. Once the function executes a return statement, the program exits the function and continues with its next executable statement. If the function does not need to return any value, you can omit the return statement, but putting either null or exit code returns is good practice for code maintenance. Functions can be pretty elaborate; they can search for things in a list, determine variable types, open and close files, read and write to files. To get started we will build a few really simple mathematical functions; we will need this skill in the future anyway, especially in scientific programming contexts. User-built within a Code Block For our first function we will code f(x) = x\\sqrt{1 + x} into a function named dusty() . When you run the next cell, all it does is prototype the function (defines it), nothing happens until we use the function. def dusty(x) : temp = x * ((1.0+x)**(0.5)) # don't need the math package return temp # the function should make the evaluation # store in the local variable temp # return contents of temp # wrapper to run the dusty function yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = dusty(xvalue) print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 3 f( 3.0 ) = 6.0 Variable Scope An important concept when defining a function is the concept of variable scope. Variables defined inside a function are treated differently from variables defined outside. Firstly, any variable declared within a function is only accessible within the function, unless explicitly defined otherwise (Google \"python global variable\" to learn more) These are known as local variables. In the dusty() function, the variables x and temp are local to the function. Any variable declared outside a function in a main program is known as a program variable and is accessible anywhere in the main program, but not in functions unless supplied as a parameter. In the example, the variables xvalue and yvalue are program variables (accessible to the program; if they are passed to a function, they can be operated on.) Generally we want to protect the program variables from the function unless the intent is to change their values. The way the function is written in the example, the function cannot damage xvalue or yvalue , but the contents of xvalue are operated on by the function and the results returned from dusty and stored in yvalue . If a local variable shares the same name as a program variable, any code inside the function is accessing the local variable. Any code outside is accessing the program variable def mercy(x) : temp = x * ((1.0+x)**(0.5)) # don't need the math package x = x+2 print('Value of x in mercy is: ',x) return temp x = 2 y = mercy(x) print('Value of x in main is: ',x,' Value of y is: ',y) # function did not change value of x in program Value of x in mercy is: 4 Value of x in main is: 2 Value of y is: 3.4641016151377544 Temperature Converter Example Create a Fahrenhiet to Celsius converter and test it for these values: 32 15 100 *hint: Formula-(\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C Problem Solving Process Step 1 Define the problem (problem statement): - Create a tool to convert Fahrenhiet to Celsius Step 2 Gather information (identify known and unknown values, and governing equations) - Known: Input in F - Unknown: Output in C - Governing Principles: Formula: (\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C Step 3 Generate and evaluate potential solutions - -40F = -40C - 32F = 0C - 212F = 100C Step 4 Refine and implement a solution 1. Create function to evaluate input and produce output def FC(x) : # convert F to C C = (x - 32)*5/9 return C Create a wrapper supply input, execute function, label output print(FC(99)) 37.22222222222222 Step 5 Verify and test the solution. print(FC(-40)) -40.0 print(FC(32)) 0.0 print(FC(212)) 100.0 Step 6 Refine to be useful - Modify the wrapper to be interactive def F2C(x) : # convert F to C C = (x - 32)*5/9 return C # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C References Grus, Joel (2015-04-14). Data Science from Scratch: First Principles with Python (Kindle Locations 1190-1191). O'Reilly Media. Kindle Edition. Call Expressions in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/03/3/Calls.html Functions and Tables in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/08/Functions_and_Tables.html Visualization in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/07/Visualization.html Documentation; The Python Standard Library; 9. Numeric and Mathematical Modules https://docs.python.org/2/library/math.html Code.org; Chris Bosh of Miami Heat and Jess Lee CEO of Polyvore. Let's use code to join Anna and Elsa as they explore the magic and beauty of ice. https://youtu.be/0eo0ESEX9DE ENGR-1330 Functions and Variable Scope (Fall 2020) https://3.137.111.182/engr-1330-webroot/1-Lessons/Lesson05/OriginalPowerpoint/PythonFunctions-VariableScope-ENGR1330-CTwithDS.pdf","title":"Functions"},{"location":"1-programming/13-functions/functions/#function","text":"Functions are simply pre-written code fragments that perform a certain task. In older procedural languages functions and subroutines are similar, but a function returns a value whereas a subroutine operates on data. The difference is subtle but important. More recent thinking has functions being able to operate on data (they always could) and the value returned may be simply an exit code. An analogy are the functions in MS Excel . To add numbers, we can use the sum(range) function and type =sum(A1:A5) instead of typing =A1+A2+A3+A4+A5","title":"Function"},{"location":"1-programming/13-functions/functions/#calling-the-function","text":"We call a function simply by typing the name of the function or by using the dot notation. Whether we can use the dot notation or not depends on how the function is written, whether it is part of a class, and how it is imported into a program. Some functions expect us to pass data to them to perform their tasks. These data are known as parameters( older terminology is arguments, or argument list) and we pass them to the function by enclosing their values in parenthesis ( ) separated by commas. For instance, the print() function for displaying text on the screen is \\called\" by typing print('Hello World') where print is the name of the function and the literal (a string) 'Hello World' is the argument.","title":"Calling the Function"},{"location":"1-programming/13-functions/functions/#program-flow","text":"A function, whether built-in, or added must be defined before it is called, otherwise the script will fail. Certain built-in functions \"self define\" upon start (such as print() and type() and we need not worry about those funtions). The diagram below illustrates the requesite flow control for functions that need to be defined before use. An example below will illustrate, change the cell to code and run it, you should get an error. Then fix the indicated line (remove the leading \"#\" in the import math ... line) and rerun, should get a functioning script. # reset the notebook using a magic function in JupyterLab %reset -f # An example, run once as is then activate indicated line, run again - what happens? x= 4. sqrt_by_arithmetic = x**0.5 print('Using arithmetic square root of ', x, ' is ',sqrt_by_arithmetic ) import math # import the math package ## activate and rerun sqrt_by_math = math.sqrt(x) # note the dot notation print('Using math package square root of ', x,' is ',sqrt_by_arithmetic) Using arithmetic square root of 4.0 is 2.0 Using math package square root of 4.0 is 2.0 An alternate way to load just the sqrt() function is shown below, either way is fine. # reset the notebook using a magic function in JupyterLab %reset -f # An example, run once as is then activate indicated line, run again - what happens? x= 4. sqrt_by_arithmetic = x**0.5 print('Using arithmetic square root of ', x, ' is ',sqrt_by_arithmetic ) from math import sqrt # import sqrt from the math package ## activate and rerun sqrt_by_math = sqrt(x) # note the notation print('Using math package square root of ', x,' is ',sqrt_by_arithmetic) Using arithmetic square root of 4.0 is 2.0 Using math package square root of 4.0 is 2.0","title":"Program flow"},{"location":"1-programming/13-functions/functions/#intrinsic-built-in-in-base-python","text":"The base Python functions and types built into it that are always available, the figure below lists those functions. Notice all have the structure of function_name() , except __import__() which has a constructor type structure, and is not intended for routine use. We will learn about constructors later.","title":"Intrinsic (Built-in) in Base Python"},{"location":"1-programming/13-functions/functions/#using-external-packagesmodules-and-libaries-eg-math","text":"Python is also distributed with a large number of external functions. These functions are saved in files known as modules. To use the built-in codes in Python modules, we have to import them into our programs first. We do that by using the import keyword. There are three ways to import: Import the entire module by writing import moduleName; For instance, to import the random module, we write import random. To use the randrange() function in the random module, we write random.randrange( 1, 10);28 Import and rename the module by writing import random as r (where r is any name of your choice). Now to use the randrange() function, you simply write r.randrange(1, 10); and Import specific functions from the module by writing from moduleName import name1[,name2[, ... nameN]]. For instance, to import the randrange() function from the random module, we write from random import randrange. To import multiple functions, we separate them with a comma. To import the randrange() and randint() functions, we write from random import randrange, randint. To use the function now, we do not have to use the dot notation anymore. Just write randrange( 1, 10). A couple of usually available modules that install with base python are math and array . Other modules we will use may need a separate system install (using pip or conda) are numpy , pandas , and matplotlib . This notebook is created on a Raspberry Pi running a JupyterHub server, so these modules are installed using pip. If you build your environment using Anaconda, these modules should be available simply via import . # Example 1 of import %reset -f import random low = 1 ; high = 10 random.randrange(low,high) #generate random number in range low to high 3 # Example 2 of import %reset -f import random as r #the alias r replaces random in subsequent calls low = 1 ; high = 10 r.randrange(low,high) 7 # Example 3 of import %reset -f from random import randrange # importing a single function from a module low = 1 ; high = 10 randrange(low,high) 6 The modules that come with Python are extensive and listed at https://docs.python.org/3/py-modindex.html. There are also other modules that can be downloaded and used (just like user defined modules below). In these labs we are building primitive codes to learn how to code and how to create algorithms. For many practical cases you will want to load a well-tested package to accomplish the tasks.","title":"Using External Packages/Modules and Libaries (e.g. math)"},{"location":"1-programming/13-functions/functions/#user-built","text":"We can define our own functions in Python and reuse them throughout the program. The syntax for defining a function is (the fragment below is psuedocode - it won't cut and paste!): def functionName( argument ): code detailing what the function should do note the colon above and indentation ... ... return [expression] The keyword def tells the program that the indented code from the next line onwards is part of the function. The keyword return tells the program to return an answer from the function. There can be multiple return statements in a function. Once the function executes a return statement, the program exits the function and continues with its next executable statement. If the function does not need to return any value, you can omit the return statement, but putting either null or exit code returns is good practice for code maintenance. Functions can be pretty elaborate; they can search for things in a list, determine variable types, open and close files, read and write to files. To get started we will build a few really simple mathematical functions; we will need this skill in the future anyway, especially in scientific programming contexts.","title":"User-Built"},{"location":"1-programming/13-functions/functions/#user-built-within-a-code-block","text":"For our first function we will code f(x) = x\\sqrt{1 + x} into a function named dusty() . When you run the next cell, all it does is prototype the function (defines it), nothing happens until we use the function. def dusty(x) : temp = x * ((1.0+x)**(0.5)) # don't need the math package return temp # the function should make the evaluation # store in the local variable temp # return contents of temp # wrapper to run the dusty function yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = dusty(xvalue) print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 3 f( 3.0 ) = 6.0","title":"User-built within a Code Block"},{"location":"1-programming/13-functions/functions/#variable-scope","text":"An important concept when defining a function is the concept of variable scope. Variables defined inside a function are treated differently from variables defined outside. Firstly, any variable declared within a function is only accessible within the function, unless explicitly defined otherwise (Google \"python global variable\" to learn more) These are known as local variables. In the dusty() function, the variables x and temp are local to the function. Any variable declared outside a function in a main program is known as a program variable and is accessible anywhere in the main program, but not in functions unless supplied as a parameter. In the example, the variables xvalue and yvalue are program variables (accessible to the program; if they are passed to a function, they can be operated on.) Generally we want to protect the program variables from the function unless the intent is to change their values. The way the function is written in the example, the function cannot damage xvalue or yvalue , but the contents of xvalue are operated on by the function and the results returned from dusty and stored in yvalue . If a local variable shares the same name as a program variable, any code inside the function is accessing the local variable. Any code outside is accessing the program variable def mercy(x) : temp = x * ((1.0+x)**(0.5)) # don't need the math package x = x+2 print('Value of x in mercy is: ',x) return temp x = 2 y = mercy(x) print('Value of x in main is: ',x,' Value of y is: ',y) # function did not change value of x in program Value of x in mercy is: 4 Value of x in main is: 2 Value of y is: 3.4641016151377544","title":"Variable Scope"},{"location":"1-programming/13-functions/functions/#temperature-converter-example","text":"Create a Fahrenhiet to Celsius converter and test it for these values: 32 15 100 *hint: Formula-(\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C","title":"Temperature Converter Example"},{"location":"1-programming/13-functions/functions/#problem-solving-process","text":"","title":"Problem Solving Process"},{"location":"1-programming/13-functions/functions/#step-1","text":"Define the problem (problem statement): - Create a tool to convert Fahrenhiet to Celsius","title":"Step 1"},{"location":"1-programming/13-functions/functions/#step-2","text":"Gather information (identify known and unknown values, and governing equations) - Known: Input in F - Unknown: Output in C - Governing Principles: Formula: (\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C","title":"Step 2"},{"location":"1-programming/13-functions/functions/#step-3","text":"Generate and evaluate potential solutions - -40F = -40C - 32F = 0C - 212F = 100C","title":"Step 3"},{"location":"1-programming/13-functions/functions/#step-4","text":"Refine and implement a solution 1. Create function to evaluate input and produce output def FC(x) : # convert F to C C = (x - 32)*5/9 return C Create a wrapper supply input, execute function, label output print(FC(99)) 37.22222222222222","title":"Step 4"},{"location":"1-programming/13-functions/functions/#step-5","text":"Verify and test the solution. print(FC(-40)) -40.0 print(FC(32)) 0.0 print(FC(212)) 100.0","title":"Step 5"},{"location":"1-programming/13-functions/functions/#step-6","text":"Refine to be useful - Modify the wrapper to be interactive def F2C(x) : # convert F to C C = (x - 32)*5/9 return C # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C","title":"Step 6"},{"location":"1-programming/13-functions/functions/#references","text":"Grus, Joel (2015-04-14). Data Science from Scratch: First Principles with Python (Kindle Locations 1190-1191). O'Reilly Media. Kindle Edition. Call Expressions in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/03/3/Calls.html Functions and Tables in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/08/Functions_and_Tables.html Visualization in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/07/Visualization.html Documentation; The Python Standard Library; 9. Numeric and Mathematical Modules https://docs.python.org/2/library/math.html Code.org; Chris Bosh of Miami Heat and Jess Lee CEO of Polyvore. Let's use code to join Anna and Elsa as they explore the magic and beauty of ice. https://youtu.be/0eo0ESEX9DE ENGR-1330 Functions and Variable Scope (Fall 2020) https://3.137.111.182/engr-1330-webroot/1-Lessons/Lesson05/OriginalPowerpoint/PythonFunctions-VariableScope-ENGR1330-CTwithDS.pdf","title":"References"},{"location":"1-programming/14-externalmodules/externalmodules/","text":"External Modules Modules, like functions are simply pre-written code fragments that perform a certain task. In older procedural languages modules and subroutines are similar concepts. An external module, is just a file that contains python code, that is imported into your script, then run as if it was part of the script all along. Consider the following code cells - and read the comments ! ls -l # list contents of current directory total 716 -rw-rw-r-- 1 sensei sensei 122771 Jul 22 14:27 base-functions.png -rw-rw-r-- 1 sensei sensei 194845 Jul 22 14:27 external-file-import-Copy1.png -rw-rw-r-- 1 sensei sensei 194845 Jul 22 14:27 external-file-import.png -rw-rw-r-- 1 sensei sensei 72197 Jul 22 14:31 externalmodules.ipynb -rw-rw-r-- 1 sensei sensei 113349 Jul 22 14:27 flow-control-diagram.png -rw-rw-r-- 1 sensei sensei 17790 Jul 22 14:27 functions.md -rw-rw-r-- 1 sensei sensei 4066 Jul 22 14:27 index.html -rw-rw-r-- 1 sensei sensei 174 Jul 22 14:27 mylibrary.py ! cat mylibrary.py # list contents of file named mylibrary.py def neko(input_argument) : import math #ok to import into a function local_variable = input_argument * math.sqrt(abs(1.0+input_argument)) return local_variable import mylibrary # iPython assumes the extension .py # wrapper to run the neko function yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = mylibrary.neko(xvalue) # here we call out external function print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 2 f( 2.0 ) = 3.4641016151377544 In JupyterHub environments, you may discover that changes you make to your external python file are not reflected when you re-run your script; you need to restart the kernel to get the changes to actually update. The figure below depicts the notebook, external file relatonship This relationship is levereged when we build oor own libraries as illustrated next. Saving Code as a Separate Module/File Above we imported the neko() function. Here we will create a new function, export it to a file, so we can reuse it in later notebooks without having to retype or cut-and-paste. The dusty() function evaluates: f(x) = x\\sqrt{|(1 + x)|} Its the same as the neko() function. Create a text file named \"mydusty.txt\" Copy the dusty() function script below into that file. def dusty(input_argument) : import math #ok to import into a function local_variable = input_argument * math.sqrt(abs(1.0+input_argument)) return local_variable Note: the cells below we build the file directly on the server using bash (shell) commands; you would simply open the file in an editor and type the lines above. In lecture/lab we will use an editor to make the file rename mydusty.txt to mydusty.py (This is a bit unnecessary, but if your editor gats confused, make a .txt file then rename after populated) modify the wrapper script to use the dusty function as an external module ! touch mydusty.txt # bash call to create an empty text file # bash calls to populate the file, you would normally use a text editor to create the file ! echo 'def dusty(input_argument) : ' > line1.txt ! echo ' import math #ok to import into a function' > line2.txt ! echo ' local_variable = input_argument * math.sqrt(abs(1.0+input_argument))' > line3.txt ! echo ' return local_variable' > line4.txt ! cat line1.txt line2.txt line3.txt line4.txt > mydusty.txt # build mydusty ! rm -f line*.txt # remove the temp files ! mv mydusty.txt mydusty.py # rename the populated file # wrapper to run the dusty function import mydusty yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = mydusty.dusty(xvalue) print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 2 f( 2.0 ) = 3.4641016151377544 Temperature Converter Example (Repeated) Create a Fahrenhiet to Celsius converter and test it for these values: 32 15 100 *hint: Formula-(\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C Problem Solving Process Step 1 Define the problem (problem statement): - Create a tool to convert Fahrenhiet to Celsius Step 2 Gather information (identify known and unknown values, and governing equations) - Known: Input in F - Unknown: Output in C - Governing Principles: Formula: (\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C Step 3 Generate and evaluate potential solutions - -40F = -40C - 32F = 0C - 212F = 100C Step 4 Refine and implement a solution 1. Create function to evaluate input and produce output def FC(x) : # convert F to C C = (x - 32)*5/9 return C Create wrapper to prompt for input, execute function, label output print(FC(99)) 37.22222222222222 Step 5 Verify and test the solution. print(FC(-40)) -40.0 print(FC(32)) 0.0 print(FC(212)) 100.0 Step 6 Refine to be useful - Modify the wrapper to be interactive def F2C(x) : # convert F to C C = (x - 32)*5/9 return C # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C Save the function into an external module \"myConversions.py\" # bash calls to populate the file, you would normally use a text editor to create the file ! echo 'def F2C(x) : # convert F to C' > line1.txt ! echo ' C = (x - 32)*5/9' > line2.txt ! echo ' return C' > line3.txt ! cat line1.txt line2.txt line3.txt > myConversions.py # build \"myConversions.py\" ! rm -f line*.txt # remove the temp files ! cat myConversions.py # list contents of the file def F2C(x) : # convert F to C C = (x - 32)*5/9 return C import myConversions # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = myConversions.F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C Rudimentary Graphics We can use external modules and function to make things other than strings and numbers for example consider making a script to that draws a straight line between two points and presents it as a plot. The external module is named matplotlib.pyplot and is imported in the function body, then we prompt for vertex locations (x1,y1) and (x2,y2) then draw the plot. Notice a null return statement which will return control to the main program. def drawAline(): import matplotlib.pyplot # import the plotting library from matplotlib x1 = int(input('Please enter x value for point 1')) y1 = int(input('Please enter y value for point 1')) x2 = int(input('Please enter x value for point 2')) y2 = int(input('Please enter y value for point 2')) xlist = [x1,x2] ylist = [y1,y2] matplotlib.pyplot.plot(xlist, ylist, color ='orange', marker ='*', linestyle ='solid') #matplotlib.pyplot.title(strtitle)# add a title matplotlib.pyplot.ylabel(\"Y-axis\")# add a label to the x and y-axes matplotlib.pyplot.xlabel(\"X-axis\") matplotlib.pyplot.show() # display the plot return #null return drawAline() Please enter x value for point 1 1 Please enter y value for point 1 1 Please enter x value for point 2 2 Please enter y value for point 2 2 Now lets put the plotting script into a function so we can make line charts of any two numeric lists References Grus, Joel (2015-04-14). Data Science from Scratch: First Principles with Python (Kindle Locations 1190-1191). O'Reilly Media. Kindle Edition. Call Expressions in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/03/3/Calls.html Functions and Tables in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/08/Functions_and_Tables.html Visualization in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/07/Visualization.html Documentation; The Python Standard Library; 9. Numeric and Mathematical Modules https://docs.python.org/2/library/math.html","title":"External Modules"},{"location":"1-programming/14-externalmodules/externalmodules/#external-modules","text":"Modules, like functions are simply pre-written code fragments that perform a certain task. In older procedural languages modules and subroutines are similar concepts. An external module, is just a file that contains python code, that is imported into your script, then run as if it was part of the script all along. Consider the following code cells - and read the comments ! ls -l # list contents of current directory total 716 -rw-rw-r-- 1 sensei sensei 122771 Jul 22 14:27 base-functions.png -rw-rw-r-- 1 sensei sensei 194845 Jul 22 14:27 external-file-import-Copy1.png -rw-rw-r-- 1 sensei sensei 194845 Jul 22 14:27 external-file-import.png -rw-rw-r-- 1 sensei sensei 72197 Jul 22 14:31 externalmodules.ipynb -rw-rw-r-- 1 sensei sensei 113349 Jul 22 14:27 flow-control-diagram.png -rw-rw-r-- 1 sensei sensei 17790 Jul 22 14:27 functions.md -rw-rw-r-- 1 sensei sensei 4066 Jul 22 14:27 index.html -rw-rw-r-- 1 sensei sensei 174 Jul 22 14:27 mylibrary.py ! cat mylibrary.py # list contents of file named mylibrary.py def neko(input_argument) : import math #ok to import into a function local_variable = input_argument * math.sqrt(abs(1.0+input_argument)) return local_variable import mylibrary # iPython assumes the extension .py # wrapper to run the neko function yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = mylibrary.neko(xvalue) # here we call out external function print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 2 f( 2.0 ) = 3.4641016151377544 In JupyterHub environments, you may discover that changes you make to your external python file are not reflected when you re-run your script; you need to restart the kernel to get the changes to actually update. The figure below depicts the notebook, external file relatonship This relationship is levereged when we build oor own libraries as illustrated next.","title":"External Modules"},{"location":"1-programming/14-externalmodules/externalmodules/#saving-code-as-a-separate-modulefile","text":"Above we imported the neko() function. Here we will create a new function, export it to a file, so we can reuse it in later notebooks without having to retype or cut-and-paste. The dusty() function evaluates: f(x) = x\\sqrt{|(1 + x)|} Its the same as the neko() function. Create a text file named \"mydusty.txt\" Copy the dusty() function script below into that file. def dusty(input_argument) : import math #ok to import into a function local_variable = input_argument * math.sqrt(abs(1.0+input_argument)) return local_variable Note: the cells below we build the file directly on the server using bash (shell) commands; you would simply open the file in an editor and type the lines above. In lecture/lab we will use an editor to make the file rename mydusty.txt to mydusty.py (This is a bit unnecessary, but if your editor gats confused, make a .txt file then rename after populated) modify the wrapper script to use the dusty function as an external module ! touch mydusty.txt # bash call to create an empty text file # bash calls to populate the file, you would normally use a text editor to create the file ! echo 'def dusty(input_argument) : ' > line1.txt ! echo ' import math #ok to import into a function' > line2.txt ! echo ' local_variable = input_argument * math.sqrt(abs(1.0+input_argument))' > line3.txt ! echo ' return local_variable' > line4.txt ! cat line1.txt line2.txt line3.txt line4.txt > mydusty.txt # build mydusty ! rm -f line*.txt # remove the temp files ! mv mydusty.txt mydusty.py # rename the populated file # wrapper to run the dusty function import mydusty yes = 0 while yes == 0: xvalue = input('enter a numeric value') try: xvalue = float(xvalue) yes = 1 except: print('enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = mydusty.dusty(xvalue) print('f(',xvalue,') = ',yvalue) # and we are done enter a numeric value 2 f( 2.0 ) = 3.4641016151377544","title":"Saving Code as a Separate Module/File"},{"location":"1-programming/14-externalmodules/externalmodules/#temperature-converter-example-repeated","text":"Create a Fahrenhiet to Celsius converter and test it for these values: 32 15 100 *hint: Formula-(\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C","title":"Temperature Converter Example (Repeated)"},{"location":"1-programming/14-externalmodules/externalmodules/#problem-solving-process","text":"","title":"Problem Solving Process"},{"location":"1-programming/14-externalmodules/externalmodules/#step-1","text":"Define the problem (problem statement): - Create a tool to convert Fahrenhiet to Celsius","title":"Step 1"},{"location":"1-programming/14-externalmodules/externalmodules/#step-2","text":"Gather information (identify known and unknown values, and governing equations) - Known: Input in F - Unknown: Output in C - Governing Principles: Formula: (\u00b0F \u2212 32) \u00d7 5/9 = \u00b0C","title":"Step 2"},{"location":"1-programming/14-externalmodules/externalmodules/#step-3","text":"Generate and evaluate potential solutions - -40F = -40C - 32F = 0C - 212F = 100C","title":"Step 3"},{"location":"1-programming/14-externalmodules/externalmodules/#step-4","text":"Refine and implement a solution 1. Create function to evaluate input and produce output def FC(x) : # convert F to C C = (x - 32)*5/9 return C Create wrapper to prompt for input, execute function, label output print(FC(99)) 37.22222222222222","title":"Step 4"},{"location":"1-programming/14-externalmodules/externalmodules/#step-5","text":"Verify and test the solution. print(FC(-40)) -40.0 print(FC(32)) 0.0 print(FC(212)) 100.0","title":"Step 5"},{"location":"1-programming/14-externalmodules/externalmodules/#step-6","text":"Refine to be useful - Modify the wrapper to be interactive def F2C(x) : # convert F to C C = (x - 32)*5/9 return C # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C Save the function into an external module \"myConversions.py\" # bash calls to populate the file, you would normally use a text editor to create the file ! echo 'def F2C(x) : # convert F to C' > line1.txt ! echo ' C = (x - 32)*5/9' > line2.txt ! echo ' return C' > line3.txt ! cat line1.txt line2.txt line3.txt > myConversions.py # build \"myConversions.py\" ! rm -f line*.txt # remove the temp files ! cat myConversions.py # list contents of the file def F2C(x) : # convert F to C C = (x - 32)*5/9 return C import myConversions # wrapper to run the F2C function yes = 0 while yes == 0: xvalue = input('Enter a temperature in Fairyheight') try: xvalue = float(xvalue) yes = 1 except: print('Enter a bloody number! Try again \\n') # call the function, get value , write output yvalue = myConversions.F2C(xvalue) print('Temp: ',xvalue,'F = ',yvalue,' C') # and we are done Enter a temperature in Fairyheight -40 Temp: -40.0 F = -40.0 C","title":"Step 6"},{"location":"1-programming/14-externalmodules/externalmodules/#rudimentary-graphics","text":"We can use external modules and function to make things other than strings and numbers for example consider making a script to that draws a straight line between two points and presents it as a plot. The external module is named matplotlib.pyplot and is imported in the function body, then we prompt for vertex locations (x1,y1) and (x2,y2) then draw the plot. Notice a null return statement which will return control to the main program. def drawAline(): import matplotlib.pyplot # import the plotting library from matplotlib x1 = int(input('Please enter x value for point 1')) y1 = int(input('Please enter y value for point 1')) x2 = int(input('Please enter x value for point 2')) y2 = int(input('Please enter y value for point 2')) xlist = [x1,x2] ylist = [y1,y2] matplotlib.pyplot.plot(xlist, ylist, color ='orange', marker ='*', linestyle ='solid') #matplotlib.pyplot.title(strtitle)# add a title matplotlib.pyplot.ylabel(\"Y-axis\")# add a label to the x and y-axes matplotlib.pyplot.xlabel(\"X-axis\") matplotlib.pyplot.show() # display the plot return #null return drawAline() Please enter x value for point 1 1 Please enter y value for point 1 1 Please enter x value for point 2 2 Please enter y value for point 2 2 Now lets put the plotting script into a function so we can make line charts of any two numeric lists","title":"Rudimentary Graphics"},{"location":"1-programming/14-externalmodules/externalmodules/#references","text":"Grus, Joel (2015-04-14). Data Science from Scratch: First Principles with Python (Kindle Locations 1190-1191). O'Reilly Media. Kindle Edition. Call Expressions in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/03/3/Calls.html Functions and Tables in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/08/Functions_and_Tables.html Visualization in \"Adhikari, A. and DeNero, J. Computational and Inferential Thinking The Foundations of Data Science\" https://www.inferentialthinking.com/chapters/07/Visualization.html Documentation; The Python Standard Library; 9. Numeric and Mathematical Modules https://docs.python.org/2/library/math.html","title":"References"},{"location":"1-programming/15-workingwithfiles/workingwithfiles/","text":"Working with Files words Opening and reading text (ascii) files Using loops to read text files writing to text files","title":"Working With Files"},{"location":"1-programming/15-workingwithfiles/workingwithfiles/#working-with-files","text":"words","title":"Working with Files"},{"location":"1-programming/15-workingwithfiles/workingwithfiles/#opening-and-reading-text-ascii-files","text":"","title":"Opening and reading text (ascii) files"},{"location":"1-programming/15-workingwithfiles/workingwithfiles/#using-loops-to-read-text-files","text":"","title":"Using loops to read text files"},{"location":"1-programming/15-workingwithfiles/workingwithfiles/#writing-to-text-files","text":"","title":"writing to text files"},{"location":"1-programming/16-morefilemanipulation/morefilemanipulation/","text":"More file manipulation open/read/write binary files deleting and renaming files get a file from a URL","title":"More File Manipulation"},{"location":"1-programming/16-morefilemanipulation/morefilemanipulation/#more-file-manipulation","text":"open/read/write binary files deleting and renaming files get a file from a URL","title":"More file manipulation"},{"location":"1-programming/17-workingwitharray/workingwitharray/","text":"working with array vectors and matrices array a special type of list matrix arithmetic","title":"Working with ARRAY"},{"location":"1-programming/17-workingwitharray/workingwitharray/#working-with-array","text":"vectors and matrices array a special type of list matrix arithmetic","title":"working with array"},{"location":"1-programming/18-arrayprocessingwithnumpy/arrayprocessingwithnumpy/","text":"array processing with numpy linear algebra using using numpy solve linear system in numpy example","title":"Array processing with NUMPY"},{"location":"1-programming/18-arrayprocessingwithnumpy/arrayprocessingwithnumpy/#array-processing-with-numpy","text":"linear algebra using using numpy solve linear system in numpy example","title":"array processing with numpy"},{"location":"1-programming/19-databaseconcepts/databaseconcepts/","text":"database concepts records,fields unique identifiers/keys create, read, update, delete","title":"Database Concepts"},{"location":"1-programming/19-databaseconcepts/databaseconcepts/#database-concepts","text":"records,fields unique identifiers/keys create, read, update, delete","title":"database concepts"},{"location":"1-programming/2-expressions/expressions/","text":"Expressions Consider the relativistic equation relating energy, mass, and the speed of light e = m \\cdot c^2 In this equation the symbols e , m , c , = , \\cdot , and the structure is parsed from left to right. The entire equation is an statement that instructs: place into the container named e the result of the product of the contents of containers m and c^2 . In the above statement the symbols e , m , c are names for things that can have values -- we will call these containers (or variables, or named constants). The symbols = , \\cdot , and ~^2 are instructions for various arithmetic operations -- we will call these operators. The part of the statement to the right of the = symbol is an arithmetic expression. When we attempt to write and execute python scripts - we will make various mistakes; these will generate warnings and errors, which we will repair to make a working program. Consider our statement with the container names spelled out: # Example Energy = Mass * SpeedOfLight**2 --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-4-1c1f1fa5363a> in <module> 1 #clear all variables# Example ----> 2 Energy = Mass * SpeedOfLight**2 NameError: name 'Mass' is not defined Notice how the interpreter tells us that Mass is undefined - so a simple fix is to define it and try again # Example Mass = 1000000 Energy = Mass * SpeedOfLight**2 --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-5-a4a52966e6df> in <module> 1 # Example 2 Mass = 1000000 ----> 3 Energy = Mass * SpeedOfLight**2 NameError: name 'SpeedOfLight' is not defined Notice how the interpreter now tells us that SpeedOfLight is undefined - so a simple fix is to define it and try again # Example Mass = 1000000 #kilograms SpeedOfLight = 299792458 #meters per second Energy = Mass * SpeedOfLight**2 Now the script ran without any reported errors, but we have not instructed the program on how to produce output. To keep the example simple we will just add a generic print statement. # Example Mass = 1000000 #kilograms SpeedOfLight = 299792458 #meters per second Energy = Mass * SpeedOfLight**2 print(\"Energy is:\", Energy, \"Newton meters\") Energy is: 89875517873681764000000 Newton meters Fundamental Operators Assignment Operator The = sign used in a statement is called an assignment operator (or assignment sign). The symbol means that the expression to the right of the symbol is to be evaluated and the result placed into the variable on the left side of the symbol. The \"operation\" is assignment, the \"=\" symbol is the operator name. Consider the script below x = 5 # assign constant 5 into a container named x y = 10 # assign constant 10 into a containernamed x print (x,y) # print the contents of containers x and y x=y # put contents of y into x print (x,y) # print the contents of containers x and y 5 10 10 10 Arithmetic Operators In addition to assignment we can also perform arithmetic operations on containers. The fundamental arithmetic operators are: Symbol Meaning Example = Assignment x=3 Assigns value of 3 to x. + Addition x+y Adds values in x and y. - Subtraction x-y Subtracts values in y from x. * Multiplication x*y Multiplies values in x and y. / Division x/y Divides value in x by value in y. // Floor division x//y Divide x by y, truncate result to whole number. % Modulus x%y Returns remainder when x is divided by y. ** Exponentation x y Raises value in x by value in y. ( e.g. x y) += Additive assignment x+=2 Equivalent to x = x+2. -= Subtractive assignment x-=2 Equivalent to x = x-2. *= Multiplicative assignment x*=3 Equivalent to x = x*3. /= Divide assignment x/3 Equivalent to x = x/3. Run the script in the next cell for some illustrative results arithmetic expressions # Uniary Arithmetic Operators x = 10 y = 5 print(x, y) print(x+y) print(x-y) print(x*y) print(x/y) print((x+1)//y) print((x+1)%y) print(x**y) 10 5 15 5 50 2.0 2 1 100000 # Arithmetic assignment operators x = 1 x += 2 print(type(x),x) x = 1 x -= 2 print(type(x),x) x = 1 x *=3 print(type(x),x) x = 10 x /= 2 print(type(x),x) # Interesting what division does to variable type <class 'int'> 3 <class 'int'> -1 <class 'int'> 3 <class 'float'> 5.0 simple output: print() Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3","title":"Expressions"},{"location":"1-programming/2-expressions/expressions/#expressions","text":"Consider the relativistic equation relating energy, mass, and the speed of light e = m \\cdot c^2 In this equation the symbols e , m , c , = , \\cdot , and the structure is parsed from left to right. The entire equation is an statement that instructs: place into the container named e the result of the product of the contents of containers m and c^2 . In the above statement the symbols e , m , c are names for things that can have values -- we will call these containers (or variables, or named constants). The symbols = , \\cdot , and ~^2 are instructions for various arithmetic operations -- we will call these operators. The part of the statement to the right of the = symbol is an arithmetic expression. When we attempt to write and execute python scripts - we will make various mistakes; these will generate warnings and errors, which we will repair to make a working program. Consider our statement with the container names spelled out: # Example Energy = Mass * SpeedOfLight**2 --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-4-1c1f1fa5363a> in <module> 1 #clear all variables# Example ----> 2 Energy = Mass * SpeedOfLight**2 NameError: name 'Mass' is not defined Notice how the interpreter tells us that Mass is undefined - so a simple fix is to define it and try again # Example Mass = 1000000 Energy = Mass * SpeedOfLight**2 --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-5-a4a52966e6df> in <module> 1 # Example 2 Mass = 1000000 ----> 3 Energy = Mass * SpeedOfLight**2 NameError: name 'SpeedOfLight' is not defined Notice how the interpreter now tells us that SpeedOfLight is undefined - so a simple fix is to define it and try again # Example Mass = 1000000 #kilograms SpeedOfLight = 299792458 #meters per second Energy = Mass * SpeedOfLight**2 Now the script ran without any reported errors, but we have not instructed the program on how to produce output. To keep the example simple we will just add a generic print statement. # Example Mass = 1000000 #kilograms SpeedOfLight = 299792458 #meters per second Energy = Mass * SpeedOfLight**2 print(\"Energy is:\", Energy, \"Newton meters\") Energy is: 89875517873681764000000 Newton meters","title":"Expressions"},{"location":"1-programming/2-expressions/expressions/#fundamental-operators","text":"","title":"Fundamental Operators"},{"location":"1-programming/2-expressions/expressions/#assignment-operator","text":"The = sign used in a statement is called an assignment operator (or assignment sign). The symbol means that the expression to the right of the symbol is to be evaluated and the result placed into the variable on the left side of the symbol. The \"operation\" is assignment, the \"=\" symbol is the operator name. Consider the script below x = 5 # assign constant 5 into a container named x y = 10 # assign constant 10 into a containernamed x print (x,y) # print the contents of containers x and y x=y # put contents of y into x print (x,y) # print the contents of containers x and y 5 10 10 10","title":"Assignment Operator"},{"location":"1-programming/2-expressions/expressions/#arithmetic-operators","text":"In addition to assignment we can also perform arithmetic operations on containers. The fundamental arithmetic operators are: Symbol Meaning Example = Assignment x=3 Assigns value of 3 to x. + Addition x+y Adds values in x and y. - Subtraction x-y Subtracts values in y from x. * Multiplication x*y Multiplies values in x and y. / Division x/y Divides value in x by value in y. // Floor division x//y Divide x by y, truncate result to whole number. % Modulus x%y Returns remainder when x is divided by y. ** Exponentation x y Raises value in x by value in y. ( e.g. x y) += Additive assignment x+=2 Equivalent to x = x+2. -= Subtractive assignment x-=2 Equivalent to x = x-2. *= Multiplicative assignment x*=3 Equivalent to x = x*3. /= Divide assignment x/3 Equivalent to x = x/3. Run the script in the next cell for some illustrative results","title":"Arithmetic Operators"},{"location":"1-programming/2-expressions/expressions/#arithmetic-expressions","text":"# Uniary Arithmetic Operators x = 10 y = 5 print(x, y) print(x+y) print(x-y) print(x*y) print(x/y) print((x+1)//y) print((x+1)%y) print(x**y) 10 5 15 5 50 2.0 2 1 100000 # Arithmetic assignment operators x = 1 x += 2 print(type(x),x) x = 1 x -= 2 print(type(x),x) x = 1 x *=3 print(type(x),x) x = 10 x /= 2 print(type(x),x) # Interesting what division does to variable type <class 'int'> 3 <class 'int'> -1 <class 'int'> 3 <class 'float'> 5.0","title":"arithmetic expressions"},{"location":"1-programming/2-expressions/expressions/#simple-output-print","text":"","title":"simple output: print()"},{"location":"1-programming/2-expressions/expressions/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3","title":"Readings"},{"location":"1-programming/20-databaseprocessingwithpandas/databaseprocessingwithpandas/","text":"database processing with pandas subtopic subtopic subtopic","title":"Database processing with PANDAS"},{"location":"1-programming/20-databaseprocessingwithpandas/databaseprocessingwithpandas/#database-processing-with-pandas","text":"subtopic subtopic subtopic","title":"database processing with pandas"},{"location":"1-programming/21-visualdisplayofdata/visualdisplayofdata/","text":"visual display of data plot types plot uses plot conventions","title":"Visual Display of Data"},{"location":"1-programming/21-visualdisplayofdata/visualdisplayofdata/#visual-display-of-data","text":"plot types plot uses plot conventions","title":"visual display of data"},{"location":"1-programming/22-plottingwithmatplotlab/plottingwithmatplotlab/","text":"plotting with matplotlib line plots scatter plots decorators","title":"Plotting with MATPLOTLAB"},{"location":"1-programming/22-plottingwithmatplotlab/plottingwithmatplotlab/#plotting-with-matplotlib","text":"line plots scatter plots decorators","title":"plotting with matplotlib"},{"location":"1-programming/3-datatypes/datatypes/","text":"Data Types In the computer data are all binary digits (actually 0 and +5 volts). At a higher level of abstraction data are typed into integers, real, or alphanumeric representation. The type affects the kind of arithmetic operations that are allowed (as well as the kind of arithmetic - integer versus real arithmetic; lexicographical ordering of alphanumeric , etc.) In scientific programming, a common (and really difficult to detect) source of slight inaccuracies (that tend to snowball as the program runs) is mixed mode arithmetic required because two numeric values are of different types (integer and real). Learn more from the textbook https://www.inferentialthinking.com/chapters/04/Data_Types.html Integer Integers are numbers without any fractional portion (nothing after the decimal point { which is not used in integers). Numbers like -3, -2, -1, 0, 1, 2, 200 are integers. A number like 1.1 is not an integer, and 1.0 is also not an integer (the presence of the decimal point makes the number a real). To declare an integer in Python, just assign the value to a container name as an integer. MyPhoneNumber = 14158576309 type(MyPhoneNumber) # intrinsic type function to return data type in container int Real (Float) A real or float is a number that has (or can have) a fractional portion - the number has decimal parts. The numbers 3.14159, -0.001, 11.11, 1., are all floats. The last one is especially tricky, if you don't notice the decimal point you might think it is an integer but the inclusion of the decimal point in Python tells the program that the value is to be treated as a float. To declare a float in Python, just assign a number with the radix (decimal point) to a container name. MyMassInKilos = 74.8427 type(MyMassInKilos) # intrinsic type function to return data type in container float String(Alphanumeric) A string is a data type that is treated as text elements. The usual letters are strings, but numbers can be included. The numbers in a string are simply characters and cannot be directly used in arithmetic. There are some kinds of arithmetic that can be performed on strings but generally we process string variables to capture the text nature of their contents. To declare a string in Python, just assign the variable name to a string value - the trick is the value is enclosed in quotes. The quotes are delimiters that tell the program that the characters between the quotes are characters and are to be treated as literal representation. MyName = 'Theodore' MyCatName = \"Dusty\" DustyMassInKilos = \"7.48427\" print(\"MyName is type :\",type(MyName)) print(\"MyCatName is type :\",type(MyCatName)) print(\"DustyMassInKilos is type :\",type(DustyMassInKilos)) MyName is type : <class 'str'> MyCatName is type : <class 'str'> DustyMassInKilos is type : <class 'str'> For example MyName, MyCatName, and DustyMassInKilos, are all string variables. The last assignment is made into a string by enclosing the number in the quotes. String variables can be combined using an operation called concatenation. The symbol for concatenation is the plus symbol + . Strings can also be converted to all upper case using the upper() function. The syntax for the upper() function is 'string to be upper case'.upper() . Notice the \"dot\" in the syntax. The operation passes everything to the left of the dot to the function which then operates on that content and returns the result all upper case (or an error if the input stream is not a string). # Variable Types Example MyPhoneNumber = 14158576309 MyMassInKilos = 74.8427 MyName = 'Theodore' MyCatName = \"Dusty\" DustyMassInKilos = \"7.48427\" print(\"All about me\") print(\"Name: \",MyName, \" Mass :\",MyMassInKilos,\"Kg\" ) print('Phone : ',MyPhoneNumber) print('My cat\\'s name :', MyCatName) # the \\ escape character is used to get the ' into the literal print(\"All about concatenation!\") print(\"A Silly String : \",MyCatName+MyName+DustyMassInKilos) print(\"A SILLY STRING : \", (MyCatName+MyName+DustyMassInKilos).upper()) All about me Name: Theodore Mass : 74.8427 Kg Phone : 14158576309 My cat's name : Dusty All about concatenation! A Silly String : DustyTheodore7.48427 A SILLY STRING : DUSTYTHEODORE7.48427 Strings can be formatted using the % operator or the format() function. The concepts will be introduced later on as needed, you can Google search for examples of how to do such formatting. Changing Types A data type can be changed. This activity is called type casting. Three functions allow type casting: int() , float() , and str() . The function names indicate the result of using the function, hence int() returns an integer, float() returns a oat, and str() returns a string. There is also the useful function type() which returns the type of variable. The easiest way to understand is to see an example. # Type Casting Examples MyInteger = 234 MyFloat = 876.543 MyString = 'What is your name?' print(MyInteger,MyFloat,MyString) print('Integer as float',float(MyInteger)) print('Float as integer',int(MyFloat)) print('Integer as string',str(MyInteger)) print('Integer as hexadecimal',hex(MyInteger)) print('Integer Type',type((MyInteger))) # insert the hex conversion and see what happens! 234 876.543 What is your name? Integer as float 234.0 Float as integer 876 Integer as string 234 Integer as hexadecimal 0xea Integer Type <class 'int'> Other Types Core python also has a complex() numeric type. There are useful methods that can convert to different representations for numeric types for example myint = 1234 hex(myint) '0x4d2' bin(myint) '0b10011010010' Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Data Types"},{"location":"1-programming/3-datatypes/datatypes/#data-types","text":"In the computer data are all binary digits (actually 0 and +5 volts). At a higher level of abstraction data are typed into integers, real, or alphanumeric representation. The type affects the kind of arithmetic operations that are allowed (as well as the kind of arithmetic - integer versus real arithmetic; lexicographical ordering of alphanumeric , etc.) In scientific programming, a common (and really difficult to detect) source of slight inaccuracies (that tend to snowball as the program runs) is mixed mode arithmetic required because two numeric values are of different types (integer and real). Learn more from the textbook https://www.inferentialthinking.com/chapters/04/Data_Types.html","title":"Data Types"},{"location":"1-programming/3-datatypes/datatypes/#integer","text":"Integers are numbers without any fractional portion (nothing after the decimal point { which is not used in integers). Numbers like -3, -2, -1, 0, 1, 2, 200 are integers. A number like 1.1 is not an integer, and 1.0 is also not an integer (the presence of the decimal point makes the number a real). To declare an integer in Python, just assign the value to a container name as an integer. MyPhoneNumber = 14158576309 type(MyPhoneNumber) # intrinsic type function to return data type in container int","title":"Integer"},{"location":"1-programming/3-datatypes/datatypes/#real-float","text":"A real or float is a number that has (or can have) a fractional portion - the number has decimal parts. The numbers 3.14159, -0.001, 11.11, 1., are all floats. The last one is especially tricky, if you don't notice the decimal point you might think it is an integer but the inclusion of the decimal point in Python tells the program that the value is to be treated as a float. To declare a float in Python, just assign a number with the radix (decimal point) to a container name. MyMassInKilos = 74.8427 type(MyMassInKilos) # intrinsic type function to return data type in container float","title":"Real (Float)"},{"location":"1-programming/3-datatypes/datatypes/#stringalphanumeric","text":"A string is a data type that is treated as text elements. The usual letters are strings, but numbers can be included. The numbers in a string are simply characters and cannot be directly used in arithmetic. There are some kinds of arithmetic that can be performed on strings but generally we process string variables to capture the text nature of their contents. To declare a string in Python, just assign the variable name to a string value - the trick is the value is enclosed in quotes. The quotes are delimiters that tell the program that the characters between the quotes are characters and are to be treated as literal representation. MyName = 'Theodore' MyCatName = \"Dusty\" DustyMassInKilos = \"7.48427\" print(\"MyName is type :\",type(MyName)) print(\"MyCatName is type :\",type(MyCatName)) print(\"DustyMassInKilos is type :\",type(DustyMassInKilos)) MyName is type : <class 'str'> MyCatName is type : <class 'str'> DustyMassInKilos is type : <class 'str'> For example MyName, MyCatName, and DustyMassInKilos, are all string variables. The last assignment is made into a string by enclosing the number in the quotes. String variables can be combined using an operation called concatenation. The symbol for concatenation is the plus symbol + . Strings can also be converted to all upper case using the upper() function. The syntax for the upper() function is 'string to be upper case'.upper() . Notice the \"dot\" in the syntax. The operation passes everything to the left of the dot to the function which then operates on that content and returns the result all upper case (or an error if the input stream is not a string). # Variable Types Example MyPhoneNumber = 14158576309 MyMassInKilos = 74.8427 MyName = 'Theodore' MyCatName = \"Dusty\" DustyMassInKilos = \"7.48427\" print(\"All about me\") print(\"Name: \",MyName, \" Mass :\",MyMassInKilos,\"Kg\" ) print('Phone : ',MyPhoneNumber) print('My cat\\'s name :', MyCatName) # the \\ escape character is used to get the ' into the literal print(\"All about concatenation!\") print(\"A Silly String : \",MyCatName+MyName+DustyMassInKilos) print(\"A SILLY STRING : \", (MyCatName+MyName+DustyMassInKilos).upper()) All about me Name: Theodore Mass : 74.8427 Kg Phone : 14158576309 My cat's name : Dusty All about concatenation! A Silly String : DustyTheodore7.48427 A SILLY STRING : DUSTYTHEODORE7.48427 Strings can be formatted using the % operator or the format() function. The concepts will be introduced later on as needed, you can Google search for examples of how to do such formatting.","title":"String(Alphanumeric)"},{"location":"1-programming/3-datatypes/datatypes/#changing-types","text":"A data type can be changed. This activity is called type casting. Three functions allow type casting: int() , float() , and str() . The function names indicate the result of using the function, hence int() returns an integer, float() returns a oat, and str() returns a string. There is also the useful function type() which returns the type of variable. The easiest way to understand is to see an example. # Type Casting Examples MyInteger = 234 MyFloat = 876.543 MyString = 'What is your name?' print(MyInteger,MyFloat,MyString) print('Integer as float',float(MyInteger)) print('Float as integer',int(MyFloat)) print('Integer as string',str(MyInteger)) print('Integer as hexadecimal',hex(MyInteger)) print('Integer Type',type((MyInteger))) # insert the hex conversion and see what happens! 234 876.543 What is your name? Integer as float 234.0 Float as integer 876 Integer as string 234 Integer as hexadecimal 0xea Integer Type <class 'int'>","title":"Changing Types"},{"location":"1-programming/3-datatypes/datatypes/#other-types","text":"Core python also has a complex() numeric type. There are useful methods that can convert to different representations for numeric types for example myint = 1234 hex(myint) '0x4d2' bin(myint) '0b10011010010'","title":"Other Types"},{"location":"1-programming/3-datatypes/datatypes/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Readings"},{"location":"1-programming/4-variables/variables/","text":"Variables Variables are names given to data that we want to store and manipulate in programs. A variable has a name and a value. The value representation depends on what type of object the variable represents. We have been calling these things containers, but variable is the more appropriate terminology. The utility of variables comes in when we have a structure that is universal, but values of variables within the structure will change - otherwise it would be simple enough to use named constants (a container whose name is also its value, like 3 and 5.267). Suppose we want to store the time of concentration for some hydrologic calculation. To do so, we can name a variable TimeOfConcentration , and then assign a value to the variable, for instance: TimeOfConcentration = 0.0 After this assignment statement the variable is created in the program and has a value of 0.0. The use of a decimal point in the initial assignment establishes the variable as a float (a real variable is called a floating point representation -- or just a float). print(TimeOfConcentration) 0.0 Naming Rules Variable names in Python can only contain letters (a - z, A - Z), numerals (0 - 9), or underscores. The first character cannot be a number, otherwise there is considerable freedom in naming. The names can be reasonably long. runTime , run_Time , _run_Time2 , _2runTime are all valid names, but 2runTime is not valid, and will create an error when you try to use it. # Script to illustrate variable names runTime = 1 _2runTime = 2 # change to 2runTime = 2 and rerun script runTime2 = 2 print(runTime,_2runTime,runTime2) 1 2 2 There are some reserved words that cannot be used as variable names because they have preassigned meaning in Parseltongue. These words include print , input , if , while , and for . There are several more; the interpreter won't allow you to use these names as variables and will issue an error message when you attempt to run a program with such words used as variables. while = 72 print(while) File \"<ipython-input-4-85c15d632191>\", line 1 while = 72 ^ SyntaxError: invalid syntax Variables in Expressions Recall that expressions are the \"algebraic\" constructions that are evaluated and then placed into a variable. Consider x1 = 7 + 3 * 6 / 2 - 1 The expression is evaluated from the left to right and in words is Into the object named x1 place the result of: integer 7 + (integer 6 divide by integer 2 = float 3 * integer 3 = float 9 - integer 1 = float 8) = float 15 The division operation by default produces a float result unless forced otherwise. The result is the variable x1 is a float with a value of 15.0 x1 = 7 + 3 * 6 / 2 - 1 print(x1) 15.0 Suppose we want to replace the named constant 7 with a variable, simple enough, but now future changes need only be implemented once instead of every appearance of the named constant 7. Here we are using a reset for a bit later on. %reset -f # use the reset so hex addresses in blocks below don't change when switching machines seven = 7 x1 = seven + 3 * 6 / 2 - 1 print(x1) 15.0 Why are they called named constants? Its a weird construct, but the name and the value are treated as the same thing, as depicted in the next few script blocks. The last block prints virtual memory address locations of the variables - notice how seven and 7 have the same location - this is called equivalence, but look at what happens when you change seven 7 print(7) print(7, 'is type : ',type(7)) 7 7 is type : <class 'int'> 7.7 print(7.7) print(7.7, 'is type : ',type(7.7)) 7.7 7.7 is type : <class 'float'> print(hex(id(7))) print(hex(id(7.7))) print(hex(id(seven))) seven = seven+2 print(hex(id(seven))) 0x9257e8 0xffffa9fe0ef0 0x9257e8 0x925828 So assuming the memory locations are approximately sequential then \"7\" and \"seven\" start out at the same location, but after execution of seven=seven+2 the result is stored about 40 addresses away as shown: Readings Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Reverse lookup contents of a memory address https://stackoverflow.com/questions/8250625/access-memory-address-in-pytho Finding memory address https://www.codespeedy.com/find-the-memory-address-of-a-variable-in-python/","title":"Variables"},{"location":"1-programming/4-variables/variables/#variables","text":"Variables are names given to data that we want to store and manipulate in programs. A variable has a name and a value. The value representation depends on what type of object the variable represents. We have been calling these things containers, but variable is the more appropriate terminology. The utility of variables comes in when we have a structure that is universal, but values of variables within the structure will change - otherwise it would be simple enough to use named constants (a container whose name is also its value, like 3 and 5.267). Suppose we want to store the time of concentration for some hydrologic calculation. To do so, we can name a variable TimeOfConcentration , and then assign a value to the variable, for instance: TimeOfConcentration = 0.0 After this assignment statement the variable is created in the program and has a value of 0.0. The use of a decimal point in the initial assignment establishes the variable as a float (a real variable is called a floating point representation -- or just a float). print(TimeOfConcentration) 0.0","title":"Variables"},{"location":"1-programming/4-variables/variables/#naming-rules","text":"Variable names in Python can only contain letters (a - z, A - Z), numerals (0 - 9), or underscores. The first character cannot be a number, otherwise there is considerable freedom in naming. The names can be reasonably long. runTime , run_Time , _run_Time2 , _2runTime are all valid names, but 2runTime is not valid, and will create an error when you try to use it. # Script to illustrate variable names runTime = 1 _2runTime = 2 # change to 2runTime = 2 and rerun script runTime2 = 2 print(runTime,_2runTime,runTime2) 1 2 2 There are some reserved words that cannot be used as variable names because they have preassigned meaning in Parseltongue. These words include print , input , if , while , and for . There are several more; the interpreter won't allow you to use these names as variables and will issue an error message when you attempt to run a program with such words used as variables. while = 72 print(while) File \"<ipython-input-4-85c15d632191>\", line 1 while = 72 ^ SyntaxError: invalid syntax","title":"Naming Rules"},{"location":"1-programming/4-variables/variables/#variables-in-expressions","text":"Recall that expressions are the \"algebraic\" constructions that are evaluated and then placed into a variable. Consider x1 = 7 + 3 * 6 / 2 - 1 The expression is evaluated from the left to right and in words is Into the object named x1 place the result of: integer 7 + (integer 6 divide by integer 2 = float 3 * integer 3 = float 9 - integer 1 = float 8) = float 15 The division operation by default produces a float result unless forced otherwise. The result is the variable x1 is a float with a value of 15.0 x1 = 7 + 3 * 6 / 2 - 1 print(x1) 15.0 Suppose we want to replace the named constant 7 with a variable, simple enough, but now future changes need only be implemented once instead of every appearance of the named constant 7. Here we are using a reset for a bit later on. %reset -f # use the reset so hex addresses in blocks below don't change when switching machines seven = 7 x1 = seven + 3 * 6 / 2 - 1 print(x1) 15.0 Why are they called named constants? Its a weird construct, but the name and the value are treated as the same thing, as depicted in the next few script blocks. The last block prints virtual memory address locations of the variables - notice how seven and 7 have the same location - this is called equivalence, but look at what happens when you change seven 7 print(7) print(7, 'is type : ',type(7)) 7 7 is type : <class 'int'> 7.7 print(7.7) print(7.7, 'is type : ',type(7.7)) 7.7 7.7 is type : <class 'float'> print(hex(id(7))) print(hex(id(7.7))) print(hex(id(seven))) seven = seven+2 print(hex(id(seven))) 0x9257e8 0xffffa9fe0ef0 0x9257e8 0x925828 So assuming the memory locations are approximately sequential then \"7\" and \"seven\" start out at the same location, but after execution of seven=seven+2 the result is stored about 40 addresses away as shown:","title":"Variables in Expressions"},{"location":"1-programming/4-variables/variables/#readings","text":"Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) (https://runestone.academy/runestone/books/published/thinkcspy/index.html) Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Reverse lookup contents of a memory address https://stackoverflow.com/questions/8250625/access-memory-address-in-pytho Finding memory address https://www.codespeedy.com/find-the-memory-address-of-a-variable-in-python/","title":"Readings"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/","text":"Mutable Data Structures What is a data structure? Data Structures are a specialized means of organizing and storing data in computers in such a way that we can perform operations on the stored data more effectively, and maintain the program easier. In our iPython world the most common structures are illustrated in the figure below; here we are interested primarily in lists and dictionaries; the array structure is a special type of list that is explored later on, and the set is a special type of dictionary. Tuples are immutable, so are also left for later. What is mutable? A definition from https://www.dictionary.com/browse/mutable is mutable [ myoo-tuh-buhl ] See synonyms for: mutable / mutability on https://www.thesaurus.com/ adjective liable or subject to change or alteration. given to changing; constantly changing; fickle or inconstant: the mutable ways of fortune. Computers. (in object-oriented programming) of or noting an object having properties whose values can change while the object itself maintains a unique identity. The last definition is the one we seek, a mutable structure can have changing contents but the structure itself maintains identity. A named constant 7 which we cannot change, is immutable, but a variable like seven which can change is in contrast, mutable. Lists A list is a collection of data that are somehow related. It is a convenient way to refer to a collection of similar things by a single name, and using an index (like a subscript in math) to identify a particular item. Consider the \"math-like\" variable x below: \\begin{gather} x_0= 7 \\\\ x_1= 11 \\\\ x_2= 5 \\\\ x_3= 9 \\\\ x_4= 13 \\\\ x_5= 223 \\\\ \\end{gather} The variable name is x and the subscripts correspond to different values. Thus the value of the variable named x associated with subscript 3 is the number 9 . In our scripts the concept of subscript is replaced by a position or index, but it performs the same role - it identifies the particular container in the list, and lets us access the contents of the container. The figure below is a visual representation of a the concept that treats a variable as a collection of cells. In the figure, the variable name is MyList , the subscripts are replaced by a position (index) indicator that identifies which cell is being referenced. The value is the cell content at the particular index. So in the figure the value of MyList at Position Index = 3 is the number 9.' In engineering and data science we use lists a lot - we often call then vectors, arrays, matrices and such, but they are ultimately just lists. To declare a list you can write the list name and assign it values. The square brackets are used to identify that the variable is a list. Like: %reset -f MyList = [7,11,5,9,13,223] print(MyList) [7, 11, 5, 9, 13, 223] One can also declare a null list and use the append() method to fill it as needed. MyOtherList = [ ] print(MyOtherList) MyOtherList.append(1) print(MyOtherList) MyOtherList.append(2) print(MyOtherList) [] [1] [1, 2] Python indices start at ZERO . A lot of other languages start at ONE. It's just the convention. The first element in a list has an index of 0, the second an index of 1, and so on. We access the contents of a list by referring to its name and index. For example print(MyList[0]) print(MyList[3]) 7 9 Lists can store elements of different data types Ordered: Elements in a list can be indexed Mutable: Elements in a list can be altered Mathematical operations must be applied to each element of the list Dictionary - A special kind of list A dictionary is a special kind of list where the items are related data PAIRS . It is a lot like a relational database (it probably is one in fact) where the first item in the pair is called the key, and must be unique in a dictionary, and the second item in the pair is the data. The second item could itself be a list, so a dictionary would be a meaningful way to build a database in Python. To declare a dictionary using curly brackets MyPetsNamesAndMass = { \"Dusty\":7.8 , \"Aspen\":6.3, \"Merrimee\":0.03} To declare a dictionary using the dict() method MyPetsNamesAndMassToo = dict(Dusty = 7.8 , Aspen = 6.3, Merrimee = 0.03) Dictionary properties Unordered: Elements in a dictionary are not indexed (address by their key) Mutable elements: Elements themselves in a dictionary can be altered Immutable keys: Keys in a dictionary cannot be altered Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Data Structures (mutable)"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#mutable-data-structures","text":"","title":"Mutable Data Structures"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#what-is-a-data-structure","text":"Data Structures are a specialized means of organizing and storing data in computers in such a way that we can perform operations on the stored data more effectively, and maintain the program easier. In our iPython world the most common structures are illustrated in the figure below; here we are interested primarily in lists and dictionaries; the array structure is a special type of list that is explored later on, and the set is a special type of dictionary. Tuples are immutable, so are also left for later.","title":"What is a data structure?"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#what-is-mutable","text":"A definition from https://www.dictionary.com/browse/mutable is mutable [ myoo-tuh-buhl ] See synonyms for: mutable / mutability on https://www.thesaurus.com/ adjective liable or subject to change or alteration. given to changing; constantly changing; fickle or inconstant: the mutable ways of fortune. Computers. (in object-oriented programming) of or noting an object having properties whose values can change while the object itself maintains a unique identity. The last definition is the one we seek, a mutable structure can have changing contents but the structure itself maintains identity. A named constant 7 which we cannot change, is immutable, but a variable like seven which can change is in contrast, mutable.","title":"What is mutable?"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#lists","text":"A list is a collection of data that are somehow related. It is a convenient way to refer to a collection of similar things by a single name, and using an index (like a subscript in math) to identify a particular item. Consider the \"math-like\" variable x below: \\begin{gather} x_0= 7 \\\\ x_1= 11 \\\\ x_2= 5 \\\\ x_3= 9 \\\\ x_4= 13 \\\\ x_5= 223 \\\\ \\end{gather} The variable name is x and the subscripts correspond to different values. Thus the value of the variable named x associated with subscript 3 is the number 9 . In our scripts the concept of subscript is replaced by a position or index, but it performs the same role - it identifies the particular container in the list, and lets us access the contents of the container. The figure below is a visual representation of a the concept that treats a variable as a collection of cells. In the figure, the variable name is MyList , the subscripts are replaced by a position (index) indicator that identifies which cell is being referenced. The value is the cell content at the particular index. So in the figure the value of MyList at Position Index = 3 is the number 9.' In engineering and data science we use lists a lot - we often call then vectors, arrays, matrices and such, but they are ultimately just lists. To declare a list you can write the list name and assign it values. The square brackets are used to identify that the variable is a list. Like: %reset -f MyList = [7,11,5,9,13,223] print(MyList) [7, 11, 5, 9, 13, 223] One can also declare a null list and use the append() method to fill it as needed. MyOtherList = [ ] print(MyOtherList) MyOtherList.append(1) print(MyOtherList) MyOtherList.append(2) print(MyOtherList) [] [1] [1, 2] Python indices start at ZERO . A lot of other languages start at ONE. It's just the convention. The first element in a list has an index of 0, the second an index of 1, and so on. We access the contents of a list by referring to its name and index. For example print(MyList[0]) print(MyList[3]) 7 9 Lists can store elements of different data types Ordered: Elements in a list can be indexed Mutable: Elements in a list can be altered Mathematical operations must be applied to each element of the list","title":"Lists"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#dictionary-a-special-kind-of-list","text":"A dictionary is a special kind of list where the items are related data PAIRS . It is a lot like a relational database (it probably is one in fact) where the first item in the pair is called the key, and must be unique in a dictionary, and the second item in the pair is the data. The second item could itself be a list, so a dictionary would be a meaningful way to build a database in Python. To declare a dictionary using curly brackets MyPetsNamesAndMass = { \"Dusty\":7.8 , \"Aspen\":6.3, \"Merrimee\":0.03} To declare a dictionary using the dict() method MyPetsNamesAndMassToo = dict(Dusty = 7.8 , Aspen = 6.3, Merrimee = 0.03) Dictionary properties Unordered: Elements in a dictionary are not indexed (address by their key) Mutable elements: Elements themselves in a dictionary can be altered Immutable keys: Keys in a dictionary cannot be altered","title":"Dictionary - A special kind of list"},{"location":"1-programming/5-mutabledatastructures/mutabledatastructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science)","title":"Readings"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/","text":"Immutable Data Structures Data Structures are a specialized means of organizing and storing data in computers in such a way that we can perform operations on the stored data more effectively, and maintain the program easier. Here we are interested in tuples, which are immutable , but quite useful. Tuple - A special list A tuple is a special kind of list where the values cannot be changed after the list is created. Such a property is called immutable It is useful for list-like things that are static - like days in a week, or months of a year. You declare a tuple like a list, except use round brackets instead of square brackets. MyTupleName = (\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\") print(MyTupleName) ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') Tuples are often created as output from packages and functions, so often when using other's work you have to detect tupality and modify your script accordingly. You access the individual values of a tuple using their indexes, just like with a list. print(MyTupleName[0]) print(MyTupleName[-1]) Jan Dec Tuples can be leveraged using a concatenation type operation and a multiply (better to call it a repeat) operator as: print(MyTupleName + ('duodec','symjan')) # add to a tuple print(MyTupleName[0:3]*2) #repeat a tuple 'Dec' in MyTupleName # query a tuple - for whole entry ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'duodec', 'symjan') ('Jan', 'Feb', 'Mar', 'Jan', 'Feb', 'Mar') True Special Structures: Sets Sets are used to store elements of different data types, they are similar to dictionaries with keys but no values (or the keys are the values) Unordered: Elements in a set cannot be indexed Mutable: Elements in a set can be altered Non-repetition: Elements in a set are unique Elements of a set are enclosed in curly brackets { } or created using the set() method. Creating sets that contains different data types Sets cannot be nested myset = {1:'one',2:'two',3:{1:'one',2:'two',3:'seven of nine'}} type(myset) dict (myset.get(3)).get(3) # get element from key 3 of key 3 set 'seven of nine' myset = {1,2,77} type(myset) set urset={'apple','cat','rock',77,'sunset strip'} type(urset) set # union (join) sets print('union is : ' ,myset | urset) # intersection of sets (shared elements) print('intersection is : ' ,myset & urset) union is : {1, 2, 'apple', 'cat', 'sunset strip', 77, 'rock'} intersection is : {77} A good tutorial on sets and their use in python is https://realpython.com/python-sets/ What's the difference between a set and dictionary? From https://stackoverflow.com/questions/34370599/difference-between-dict-and-set-python \"Well, a set is like a dict with keys but no values, and they're both implemented using a hash table. But yes, it's a little annoying that the {} notation denotes an empty dict rather than an empty set , but that's a historical artifact.\" Special Structures: Arrays Arrays are lists that are used to store only elements of a specific data type Ordered: Elements in an array can be indexed Mutable: Elements in an array can be altered Data type that an array must hold is specified using the type code when it is created - \u2018f\u2019 for float - \u2018d\u2019 for double - \u2018i\u2019 for signed int - \u2018I\u2019 for unsigned int More types are listed below Type Code C Data Type Python Data Type Minimum Size in Bytes 'b' signed char int 1 'B' unsigned char int 1 'h' signed short int 2 'H' unsigned short int 2 'i' signed int int 2 'I' unsigned int int 2 'l' signed long int 4 'L' unsigned long int 4 'q' signed long long int 8 'Q' unsigned long long int 8 'f' float float 4 'd' double float 8 To use arrays, a library named \u2018array\u2019 must be imported (the library installs as part of core, so usually just an import is required) import array Creating an array that contains signed integer numbers myarray = array.array('i', [1, 2, 4, 8, 16, 32]) myarray[0] #1-st element, 0-th position 1 Higher dimensional arrays (matrices) require a constructor type assembly, which is presented later. The numpy module simplifies higher dimensional array construction and is probably used the most. Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Sets (tutorial) https://realpython.com/python-sets/ Arrays (tutorial) https://www.geeksforgeeks.org/python-using-2d-arrays-lists-the-right-way/","title":"Data Structures (immutable)"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#immutable-data-structures","text":"Data Structures are a specialized means of organizing and storing data in computers in such a way that we can perform operations on the stored data more effectively, and maintain the program easier. Here we are interested in tuples, which are immutable , but quite useful.","title":"Immutable Data Structures"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#tuple-a-special-list","text":"A tuple is a special kind of list where the values cannot be changed after the list is created. Such a property is called immutable It is useful for list-like things that are static - like days in a week, or months of a year. You declare a tuple like a list, except use round brackets instead of square brackets. MyTupleName = (\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\") print(MyTupleName) ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') Tuples are often created as output from packages and functions, so often when using other's work you have to detect tupality and modify your script accordingly. You access the individual values of a tuple using their indexes, just like with a list. print(MyTupleName[0]) print(MyTupleName[-1]) Jan Dec Tuples can be leveraged using a concatenation type operation and a multiply (better to call it a repeat) operator as: print(MyTupleName + ('duodec','symjan')) # add to a tuple print(MyTupleName[0:3]*2) #repeat a tuple 'Dec' in MyTupleName # query a tuple - for whole entry ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'duodec', 'symjan') ('Jan', 'Feb', 'Mar', 'Jan', 'Feb', 'Mar') True","title":"Tuple - A special list"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#special-structures-sets","text":"Sets are used to store elements of different data types, they are similar to dictionaries with keys but no values (or the keys are the values) Unordered: Elements in a set cannot be indexed Mutable: Elements in a set can be altered Non-repetition: Elements in a set are unique Elements of a set are enclosed in curly brackets { } or created using the set() method. Creating sets that contains different data types Sets cannot be nested myset = {1:'one',2:'two',3:{1:'one',2:'two',3:'seven of nine'}} type(myset) dict (myset.get(3)).get(3) # get element from key 3 of key 3 set 'seven of nine' myset = {1,2,77} type(myset) set urset={'apple','cat','rock',77,'sunset strip'} type(urset) set # union (join) sets print('union is : ' ,myset | urset) # intersection of sets (shared elements) print('intersection is : ' ,myset & urset) union is : {1, 2, 'apple', 'cat', 'sunset strip', 77, 'rock'} intersection is : {77} A good tutorial on sets and their use in python is https://realpython.com/python-sets/","title":"Special Structures: Sets"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#whats-the-difference-between-a-set-and-dictionary","text":"From https://stackoverflow.com/questions/34370599/difference-between-dict-and-set-python \"Well, a set is like a dict with keys but no values, and they're both implemented using a hash table. But yes, it's a little annoying that the {} notation denotes an empty dict rather than an empty set , but that's a historical artifact.\"","title":"What's the difference between a set and dictionary?"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#special-structures-arrays","text":"Arrays are lists that are used to store only elements of a specific data type Ordered: Elements in an array can be indexed Mutable: Elements in an array can be altered Data type that an array must hold is specified using the type code when it is created - \u2018f\u2019 for float - \u2018d\u2019 for double - \u2018i\u2019 for signed int - \u2018I\u2019 for unsigned int More types are listed below Type Code C Data Type Python Data Type Minimum Size in Bytes 'b' signed char int 1 'B' unsigned char int 1 'h' signed short int 2 'H' unsigned short int 2 'i' signed int int 2 'I' unsigned int int 2 'l' signed long int 4 'L' unsigned long int 4 'q' signed long long int 8 'Q' unsigned long long int 8 'f' float float 4 'd' double float 8 To use arrays, a library named \u2018array\u2019 must be imported (the library installs as part of core, so usually just an import is required) import array Creating an array that contains signed integer numbers myarray = array.array('i', [1, 2, 4, 8, 16, 32]) myarray[0] #1-st element, 0-th position 1 Higher dimensional arrays (matrices) require a constructor type assembly, which is presented later. The numpy module simplifies higher dimensional array construction and is probably used the most.","title":"Special Structures: Arrays"},{"location":"1-programming/6-immutabledatastructures/immutabledatastructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Sets (tutorial) https://realpython.com/python-sets/ Arrays (tutorial) https://www.geeksforgeeks.org/python-using-2d-arrays-lists-the-right-way/","title":"Readings"},{"location":"1-programming/7-userinteraction/userinteraction/","text":"User Interaction Until this point we have explicitly specified input values for variables (and constants) in a script; now lets leverage intrinsic functions that lets us makes use of variables. We\u2019ll revisit earlier examples, but this time we\u2019ll make them interactive. Instead of just computing and sending output, we want read into variables values that may change from time to time. In order to do that, our script needs to be able to prompt us for information and display them on the screen. This whole process is the essence of user interaction, and from the simple examples herein, one builds more complex scripts. The input() method Consider and run the script below MyName=input('What is your name ?') print(MyName) What is your name ? Jimmy Johns Jimmy Johns The input method sent the string 'What is your name ?' to the screen, and then waited for the user to reply. Upon reply, the input supplied was captured and then placed into the variable named MyName . Then the next statement, used the print() method to print the contents of MyName back to the screen. From this simple structure we can create quite useful input and output. As a matter of good practice, we should explicitly type the input variable, as shown below which takes the input stream and converts it into a string. MyName=str(input('What is your name ?')) print(MyName) What is your name ? Taco Bell Taco Bell Below we prompt for a second input, in this case the user's age, which will be put into an integer. As a sdie note, we are not error checking, so if an input stream that cannot be made into an integer is suppplied we will get an exception warning or an error message. MyAge=int(input('How old are you ? ')) print(MyAge) How old are you ? 66 66 The print() method The print() function is used to display information to users. It accepts zero or more expressions as parameters, separated by commas. Consider the statement below, how many parameters are in the parameter list? print (\"Hello World, my name is\", MyName, \"and I am\", MyAge, \"years old.\") Hello World, my name is Taco Bell and I am 66 years old. There are five parameters; \"Hello World, my name is\" MyName \"and I am\" MyAge \"years old\" Three of the parameters are string literals and are enclosed in quote marks, two are variables that are rendered as strings. The % operator Strings can be formatted using the % operator. This gives you greater control over how you want your string to be displayed and stored. The syntax for using the % operator is \u201cstring to be formatted\u201d %(values or variables to be inserted into string, separated by commas) An example using the string constructor ( % ) form using a placeholder in the print function call is: print (\"Hello World, my name is %s and I am %s years old.\" %(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Notice the syntax above. The contents of the two variables are placed in the locations within the string indicated by the %s symbol, the tuple (MyName,MyAge) is parsed using this placeholder and converted into a string by the trailing s in the %s indicator. See what happens if we change the second %s into %f and run the script: print (\"Hello World, my name is %s and I am %f years old.\" %(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66.000000 years old. The change to %f turns the rendered tuple value into a float. Using these structures gives us a lot of output flexibility. The format() method Similar to the % operator structure there is a format() method. Using the same example, the %s symbol is replaced by a pair of curly brackets {} playing the same placeholder role, and the format keyword precedes the tuple as print (\"Hello World, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Observe the keyword format is joined to the string with a dot notation, because format is a formal method associated with all strings, and it attached when the string literal is created. In this example the arguments to the method are the two variables, but other arguments and decorators are possible allowing for elaborate outputs. Triple quotes If you need to display a long message, you can use the triple-quote symbol (\u2018\u2019\u2019 or \u201c\u201d\u201d) to span the message over multiple lines. For instance: print ('''Hello World, my name is {} and I am a resturant that is over {} years old. We serve sodium chloride infused lipids in a variety of shapes'''.format(MyName,MyAge)) Hello World, my name is Taco Bell and I am a resturant that is over 66 years old. We serve sodium chloride infused lipids in a variety of shapes Creating an array that contains signed integer numbers Escape Characters Sometimes we may need to print some special \u201cunprintable\u201d characters such as a tab or a newline. In this case, you need to use the \\ (backslash) character to escape characters that otherwise have a different meaning. For instance to print a tab, we type the backslash character before the letter t, like this \\t using our same example we have: print (\"Hello\\t World, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Here are a few more examples: #newline after World print (\"Hello World\\n, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World , my name is Taco Bell and I am 66 years old. # backslash after World print (\"Hello World\\\\, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World\\, my name is Taco Bell and I am 66 years old. # embedded quotes in the string literal print (\"I am 5'9\\\" tall\") I am 5'9\" tall If you do not want characters preceded by the \\ character to be interpreted as special characters, you can use raw strings by adding an r before the first quote. For instance, if you do not want \\t to be interpreted as a tab in the string literal \"Hello\\tWorld\", you would type print(r\"Hello\\tWorld\") Hello\\tWorld Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) String Literals https://bic-berkeley.github.io/psych-214-fall-2016/string_literals.html Tutorial on input() and print() functions https://www.programiz.com/python-programming/input-output-import","title":"User Interaction"},{"location":"1-programming/7-userinteraction/userinteraction/#user-interaction","text":"Until this point we have explicitly specified input values for variables (and constants) in a script; now lets leverage intrinsic functions that lets us makes use of variables. We\u2019ll revisit earlier examples, but this time we\u2019ll make them interactive. Instead of just computing and sending output, we want read into variables values that may change from time to time. In order to do that, our script needs to be able to prompt us for information and display them on the screen. This whole process is the essence of user interaction, and from the simple examples herein, one builds more complex scripts.","title":"User Interaction"},{"location":"1-programming/7-userinteraction/userinteraction/#the-input-method","text":"Consider and run the script below MyName=input('What is your name ?') print(MyName) What is your name ? Jimmy Johns Jimmy Johns The input method sent the string 'What is your name ?' to the screen, and then waited for the user to reply. Upon reply, the input supplied was captured and then placed into the variable named MyName . Then the next statement, used the print() method to print the contents of MyName back to the screen. From this simple structure we can create quite useful input and output. As a matter of good practice, we should explicitly type the input variable, as shown below which takes the input stream and converts it into a string. MyName=str(input('What is your name ?')) print(MyName) What is your name ? Taco Bell Taco Bell Below we prompt for a second input, in this case the user's age, which will be put into an integer. As a sdie note, we are not error checking, so if an input stream that cannot be made into an integer is suppplied we will get an exception warning or an error message. MyAge=int(input('How old are you ? ')) print(MyAge) How old are you ? 66 66","title":"The input() method"},{"location":"1-programming/7-userinteraction/userinteraction/#the-print-method","text":"The print() function is used to display information to users. It accepts zero or more expressions as parameters, separated by commas. Consider the statement below, how many parameters are in the parameter list? print (\"Hello World, my name is\", MyName, \"and I am\", MyAge, \"years old.\") Hello World, my name is Taco Bell and I am 66 years old. There are five parameters; \"Hello World, my name is\" MyName \"and I am\" MyAge \"years old\" Three of the parameters are string literals and are enclosed in quote marks, two are variables that are rendered as strings.","title":"The print() method"},{"location":"1-programming/7-userinteraction/userinteraction/#the-operator","text":"Strings can be formatted using the % operator. This gives you greater control over how you want your string to be displayed and stored. The syntax for using the % operator is \u201cstring to be formatted\u201d %(values or variables to be inserted into string, separated by commas) An example using the string constructor ( % ) form using a placeholder in the print function call is: print (\"Hello World, my name is %s and I am %s years old.\" %(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Notice the syntax above. The contents of the two variables are placed in the locations within the string indicated by the %s symbol, the tuple (MyName,MyAge) is parsed using this placeholder and converted into a string by the trailing s in the %s indicator. See what happens if we change the second %s into %f and run the script: print (\"Hello World, my name is %s and I am %f years old.\" %(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66.000000 years old. The change to %f turns the rendered tuple value into a float. Using these structures gives us a lot of output flexibility.","title":"The % operator"},{"location":"1-programming/7-userinteraction/userinteraction/#the-format-method","text":"Similar to the % operator structure there is a format() method. Using the same example, the %s symbol is replaced by a pair of curly brackets {} playing the same placeholder role, and the format keyword precedes the tuple as print (\"Hello World, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Observe the keyword format is joined to the string with a dot notation, because format is a formal method associated with all strings, and it attached when the string literal is created. In this example the arguments to the method are the two variables, but other arguments and decorators are possible allowing for elaborate outputs.","title":"The format() method"},{"location":"1-programming/7-userinteraction/userinteraction/#triple-quotes","text":"If you need to display a long message, you can use the triple-quote symbol (\u2018\u2019\u2019 or \u201c\u201d\u201d) to span the message over multiple lines. For instance: print ('''Hello World, my name is {} and I am a resturant that is over {} years old. We serve sodium chloride infused lipids in a variety of shapes'''.format(MyName,MyAge)) Hello World, my name is Taco Bell and I am a resturant that is over 66 years old. We serve sodium chloride infused lipids in a variety of shapes Creating an array that contains signed integer numbers","title":"Triple quotes"},{"location":"1-programming/7-userinteraction/userinteraction/#escape-characters","text":"Sometimes we may need to print some special \u201cunprintable\u201d characters such as a tab or a newline. In this case, you need to use the \\ (backslash) character to escape characters that otherwise have a different meaning. For instance to print a tab, we type the backslash character before the letter t, like this \\t using our same example we have: print (\"Hello\\t World, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World, my name is Taco Bell and I am 66 years old. Here are a few more examples: #newline after World print (\"Hello World\\n, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World , my name is Taco Bell and I am 66 years old. # backslash after World print (\"Hello World\\\\, my name is {} and I am {} years old.\".format(MyName,MyAge)) Hello World\\, my name is Taco Bell and I am 66 years old. # embedded quotes in the string literal print (\"I am 5'9\\\" tall\") I am 5'9\" tall If you do not want characters preceded by the \\ character to be interpreted as special characters, you can use raw strings by adding an r before the first quote. For instance, if you do not want \\t to be interpreted as a tab in the string literal \"Hello\\tWorld\", you would type print(r\"Hello\\tWorld\") Hello\\tWorld","title":"Escape Characters"},{"location":"1-programming/7-userinteraction/userinteraction/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) String Literals https://bic-berkeley.github.io/psych-214-fall-2016/string_literals.html Tutorial on input() and print() functions https://www.programiz.com/python-programming/input-output-import","title":"Readings"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/","text":"Algorithm Building Blocks All programs are made up of three fundamental patterns of control or flow: Sequence - one instruction after another Selection (Conditional) - A group of instructions may or may not be executed, depending on some condition Repetition (Loop) \u2013 A group of instructions repeated multiple times Sequential Structure All programs are made up of combinations of these patterns (plus one more we\u2019ll discuss later). The simplest pattern, sequence, means that one computer instruction, or \u201cline of code\u201d is executed after another, in sequence. It is the default pattern. %reset -f x = 5 y = 10 x = x + y print(x) 15 In a Jupyter notebook, the instructions in a cell are executed, following the pattern(s) in the code in that cell. The code in cells form a continuous program, but the order depends on the order of the cells the user chooses to execute. x = 5 y = 10 x = x + y x = x*2 x + 4 34 Selection Structures Selection is a pattern where the flow of execution branches one way or another, depending on a condition. The Python statements related to selection are if statements. if statement In the simple if statement, the body of the if statement (the indented instructions following the colon at the end of the if) is only executed if the condition evaluates to True. The statements following the if statement body that are indented at the same level as the if are always executed regardless of the value of the condition. y = 2 x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 y = y * 2 print(y) Enter value for x (numeric) 9 40 if-else statement When there are 2 possibilities, an if-else is used. The else clause (the statements indented after the else statement) are executed if the condition specified with the if is False. The else is never followed by a condition, just a colon. In the example above, the body of the if (y = 20) is executed if x < 10, and the body of the else (y = 2) is executed if x is not less than 10 (x >= 10). x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 else: y = 2 y = y * 2 print(y) Enter value for x (numeric) 9 40 if-elif-else statement When there are multiple possibilities, the the if-elif-else statement is used. An if statement may have just one if and one else clause, but it may have multiple elif (else if) clauses. In the example, the else is executed only if x is greater than 10, because the cases of x less than 10 and x equal to 10 are already covered. Notice that the == operator is used to test for equality, because = is used for assignment. Each elif clause must have its own condition, followed by a colon. x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 elif x == 10: y = 4 else: y = 2 y = y * 2 print(y) Enter value for x (numeric) 9 40 Repetition (Loop) Structures Obviously, a powerful part of programming is that you can write a single piece of code, and execute it as many times as needed, from once to millions of times. Python has two types of loop structures, the for loop and the while loop. for loop The for loop iterates (loops) over a set of values, and it is used along with the in keyword. The simplest version iterates over a set of integers created using the range() function. for index in range(3): print( index ) 0 1 2 In this case, range() produces the set of integers from 0 to 2, inclusive. Notice how the last value 3 is not returned by range(). This behavior is python specific, and range() returns values up to, but not including the stopping value - another way to interpret is start at 0 and produce 3 values, including the zero - the syntax below is more reflective of such thinking: for index in range(0,3): print( index ) 0 1 2 while loop The while loop iterates (loops) while some condition remains True. The condition is specified by a Boolean expression (True/False) x = 0 y = 10 print(x,y) while x < y: x += 2 y -= 2 print(x,y) 0 10 6 4 The statements in the loop body are executed while the condition x < y remains True. As with the for loop, the while loop statement ends in a colon, and the loop body is indented (and ends when the indentation level returns to the same level as the while. A Boolean expression is any expression that evaluates to True or False. Expression that include the relational operators or the logical operators are Boolean expressions. Also, the integer value 0 is False and a non-zero value is True, and there are other special cases, for example, the empty string \u201c\u201d is False. With while loops, the usefulness of the := (assignment that also evaluates) becomes clear. while (str := input(\"Please enter a string or 'quit' to stop: \")) != 'quit': print( \"Your string's length is \" ) print( len(str) ) Please enter a string or 'quit' to stop: what is my name Your string's length is 15 Please enter a string or 'quit' to stop: quit versus str = input(\"Please enter a string or 'quit' to stop: \") while str != 'quit': print( \"Your string's length is \" ) print( len(str) ) str = input(\"Please enter a value or 'quit' to stop: \") Please enter a string or 'quit' to stop: what is my name Your string's length is 15 Please enter a value or 'quit' to stop: quit A for loop can be considered a special case of a while loop, in the sense that a for loop continues while the end of the sequence of values has not been reached. Flowcharts What is a Flowchart? A flowchart is a type of diagram that represents a workflow or process. A flowchart can also be defined as a diagrammatic representation of an algorithm, a step-by-step approach to solving a task. Figure 2 Repair Flowchart for a Lamp https://en.wikipedia.org/wiki/Flowchart The flowchart shows the steps as boxes of various kinds, and their order by connecting the boxes with arrows. This diagrammatic representation illustrates a solution model to a given problem. Flowcharts are used in analyzing, designing, documenting or managing a process or program in various fields. There is a symbol convention (a language) as depicted in Figure 2 below (from: https://en.wikipedia.org/wiki/Flowchart) Figure 1 Flowchart Symbols https://en.wikipedia.org/wiki/Flowchart IBM engineers implemented programming flowcharts based upon Goldstine and von Neumann's unpublished report, \"Planning and coding of problems for an electronic computing instrument, Part II, Volume 1\" (1947), which is reproduced in von Neumann's collected works. The flowchart became a popular tool for describing computer algorithms, but its popularity decreased in the 1970s, when interactive computer terminals and third-generation programming languages became common tools for computer programming, since algorithms can be expressed more concisely as source code in such languages. Often pseudo-code is used, which uses the common idioms of such languages without strictly adhering to the details of a particular one. Nowadays flowcharts are still used for describing computer algorithms.[9] Modern techniques such as UML activity diagrams and Drakon-charts can be considered to be extensions of the flowchart. Nearly all flowcharts focus on on some kind of control, rather than on the particular flow itself! While quaint today, they are an effective way to document processes in a program and visualize structures. We recomend you get in the habit of making rudimentary flowcharts, at least at the supervisory level (the sandwich chart above) How are they useful? (paraphrased from https://www.breezetree.com/articles/top-reasons-to-flowchart ) Sometimes it's more effective to visualize something graphically that it is to describe it with words. That is the essence of what flowcharts do for you. Flowcharts explain a process clearly through symbols and text. Moreover, flowcharts give you the gist of the process flow in a single glance. The following are some of the more salient reasons to use flowcharts. Process Documentation / Training Materials Another common use for flowcharts is to create process documentation. Although this reason overlaps with regulatory and quality management requirements (below), many non-regulated businesses use flowcharts for their documentation as well. These can range in form from high-level procedures to low-level, detailed work instructions. You may think that this applies mainly to large organizations, but small companies can greatly benefit from flowcharting their processes as well. Small enterprises need to be nimble and organized. Standardizing their processes is a great way to achieve this. In fact, the popular entrepreneurial book The E-Myth Revisited: Why Most Small Businesses Don't Work and What to Do About It by Michael Gerber is based on the fact that small businesses are more likely to succeed if they treat their operations like a franchise. in a nutshell, this means standardizing and documenting their business processes. There's no better way to do that than with flowcharts, right? Training materials are often created using flowcharts because they're visually stimulating and easy to understand. A nicely laid out flowchart will gain and hold the reader's attention when a block of text will often fail. Workflow Management and Continuous Improvement Workflows don't manage themselves. To ensure that you are meeting your customers' needs, you need to take control of your business processes. The first step to workflow management is to define the current state of your processes by creating an \"As-Is Flowchart\". That allows you to analyze your processes for waste and inefficiency. After you have identified areas for process improvement, you can then craft new flowcharts to document the leaner processes. Programming Information technology played a big influence on the use and spread of flowcharts in the 20th century. While Dr. W. Edwards Deming was advocating their use in quality management, professionals in the data processing world were using them to flesh out their programming logic. Flowcharts were a mainstay of procedural programming, however, and with the advent of object oriented programming and various modeling tools, the use of flowcharts for programming is no longer as commonplace as it once was. That said, even with in the scope of object oriented programming, complex program logic can be modeled effectively using a flowchart. Moreover, diagramming the user's experience as they navigate through a program is a valuable prerequisite prior to designing the user interface. So flowcharts still have their place in the world of programming. Troubleshooting Guides Most of us have come across a troubleshooting flowchart at one time or another. These are usually in the form of Decision Trees that progressively narrow the range of possible solutions based on a series of criteria. The effectiveness of these types of flowcharts depends on how neatly the range of problems and solutions can fit into a simple True/False diagnosis model. A well done troubleshooting flowcharts can cut the problem solving time greatly. Regulatory and Quality Management Requirements Your business processes may be subject to regulatory requirements such as Sarbanes-Oxley (SOX), which requires that your accounting procedures be clearly defined and documented. An easy way to do this is to create accounting flowcharts for all your accounting processes. Similarly, many organizations fall under certification requirements for quality management systems - such as ISO 9000, TS 16949, or one of the many others. In such environments, flowcharts are not only useful but in certain clauses they are actually mandated. Psuedocode Define Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Algorithm Building Blocks"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#algorithm-building-blocks","text":"All programs are made up of three fundamental patterns of control or flow: Sequence - one instruction after another Selection (Conditional) - A group of instructions may or may not be executed, depending on some condition Repetition (Loop) \u2013 A group of instructions repeated multiple times","title":"Algorithm Building Blocks"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#sequential-structure","text":"All programs are made up of combinations of these patterns (plus one more we\u2019ll discuss later). The simplest pattern, sequence, means that one computer instruction, or \u201cline of code\u201d is executed after another, in sequence. It is the default pattern. %reset -f x = 5 y = 10 x = x + y print(x) 15 In a Jupyter notebook, the instructions in a cell are executed, following the pattern(s) in the code in that cell. The code in cells form a continuous program, but the order depends on the order of the cells the user chooses to execute. x = 5 y = 10 x = x + y x = x*2 x + 4 34","title":"Sequential Structure"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#selection-structures","text":"Selection is a pattern where the flow of execution branches one way or another, depending on a condition. The Python statements related to selection are if statements. if statement In the simple if statement, the body of the if statement (the indented instructions following the colon at the end of the if) is only executed if the condition evaluates to True. The statements following the if statement body that are indented at the same level as the if are always executed regardless of the value of the condition. y = 2 x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 y = y * 2 print(y) Enter value for x (numeric) 9 40 if-else statement When there are 2 possibilities, an if-else is used. The else clause (the statements indented after the else statement) are executed if the condition specified with the if is False. The else is never followed by a condition, just a colon. In the example above, the body of the if (y = 20) is executed if x < 10, and the body of the else (y = 2) is executed if x is not less than 10 (x >= 10). x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 else: y = 2 y = y * 2 print(y) Enter value for x (numeric) 9 40 if-elif-else statement When there are multiple possibilities, the the if-elif-else statement is used. An if statement may have just one if and one else clause, but it may have multiple elif (else if) clauses. In the example, the else is executed only if x is greater than 10, because the cases of x less than 10 and x equal to 10 are already covered. Notice that the == operator is used to test for equality, because = is used for assignment. Each elif clause must have its own condition, followed by a colon. x = int(input('Enter value for x (numeric)')) if x < 10: y = 20 elif x == 10: y = 4 else: y = 2 y = y * 2 print(y) Enter value for x (numeric) 9 40","title":"Selection Structures"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#repetition-loop-structures","text":"Obviously, a powerful part of programming is that you can write a single piece of code, and execute it as many times as needed, from once to millions of times. Python has two types of loop structures, the for loop and the while loop. for loop The for loop iterates (loops) over a set of values, and it is used along with the in keyword. The simplest version iterates over a set of integers created using the range() function. for index in range(3): print( index ) 0 1 2 In this case, range() produces the set of integers from 0 to 2, inclusive. Notice how the last value 3 is not returned by range(). This behavior is python specific, and range() returns values up to, but not including the stopping value - another way to interpret is start at 0 and produce 3 values, including the zero - the syntax below is more reflective of such thinking: for index in range(0,3): print( index ) 0 1 2 while loop The while loop iterates (loops) while some condition remains True. The condition is specified by a Boolean expression (True/False) x = 0 y = 10 print(x,y) while x < y: x += 2 y -= 2 print(x,y) 0 10 6 4 The statements in the loop body are executed while the condition x < y remains True. As with the for loop, the while loop statement ends in a colon, and the loop body is indented (and ends when the indentation level returns to the same level as the while. A Boolean expression is any expression that evaluates to True or False. Expression that include the relational operators or the logical operators are Boolean expressions. Also, the integer value 0 is False and a non-zero value is True, and there are other special cases, for example, the empty string \u201c\u201d is False. With while loops, the usefulness of the := (assignment that also evaluates) becomes clear. while (str := input(\"Please enter a string or 'quit' to stop: \")) != 'quit': print( \"Your string's length is \" ) print( len(str) ) Please enter a string or 'quit' to stop: what is my name Your string's length is 15 Please enter a string or 'quit' to stop: quit versus str = input(\"Please enter a string or 'quit' to stop: \") while str != 'quit': print( \"Your string's length is \" ) print( len(str) ) str = input(\"Please enter a value or 'quit' to stop: \") Please enter a string or 'quit' to stop: what is my name Your string's length is 15 Please enter a value or 'quit' to stop: quit A for loop can be considered a special case of a while loop, in the sense that a for loop continues while the end of the sequence of values has not been reached.","title":"Repetition (Loop) Structures"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#flowcharts","text":"","title":"Flowcharts"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#what-is-a-flowchart","text":"A flowchart is a type of diagram that represents a workflow or process. A flowchart can also be defined as a diagrammatic representation of an algorithm, a step-by-step approach to solving a task. Figure 2 Repair Flowchart for a Lamp https://en.wikipedia.org/wiki/Flowchart The flowchart shows the steps as boxes of various kinds, and their order by connecting the boxes with arrows. This diagrammatic representation illustrates a solution model to a given problem. Flowcharts are used in analyzing, designing, documenting or managing a process or program in various fields. There is a symbol convention (a language) as depicted in Figure 2 below (from: https://en.wikipedia.org/wiki/Flowchart) Figure 1 Flowchart Symbols https://en.wikipedia.org/wiki/Flowchart IBM engineers implemented programming flowcharts based upon Goldstine and von Neumann's unpublished report, \"Planning and coding of problems for an electronic computing instrument, Part II, Volume 1\" (1947), which is reproduced in von Neumann's collected works. The flowchart became a popular tool for describing computer algorithms, but its popularity decreased in the 1970s, when interactive computer terminals and third-generation programming languages became common tools for computer programming, since algorithms can be expressed more concisely as source code in such languages. Often pseudo-code is used, which uses the common idioms of such languages without strictly adhering to the details of a particular one. Nowadays flowcharts are still used for describing computer algorithms.[9] Modern techniques such as UML activity diagrams and Drakon-charts can be considered to be extensions of the flowchart. Nearly all flowcharts focus on on some kind of control, rather than on the particular flow itself! While quaint today, they are an effective way to document processes in a program and visualize structures. We recomend you get in the habit of making rudimentary flowcharts, at least at the supervisory level (the sandwich chart above)","title":"What is a Flowchart?"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#how-are-they-useful","text":"(paraphrased from https://www.breezetree.com/articles/top-reasons-to-flowchart ) Sometimes it's more effective to visualize something graphically that it is to describe it with words. That is the essence of what flowcharts do for you. Flowcharts explain a process clearly through symbols and text. Moreover, flowcharts give you the gist of the process flow in a single glance. The following are some of the more salient reasons to use flowcharts. Process Documentation / Training Materials Another common use for flowcharts is to create process documentation. Although this reason overlaps with regulatory and quality management requirements (below), many non-regulated businesses use flowcharts for their documentation as well. These can range in form from high-level procedures to low-level, detailed work instructions. You may think that this applies mainly to large organizations, but small companies can greatly benefit from flowcharting their processes as well. Small enterprises need to be nimble and organized. Standardizing their processes is a great way to achieve this. In fact, the popular entrepreneurial book The E-Myth Revisited: Why Most Small Businesses Don't Work and What to Do About It by Michael Gerber is based on the fact that small businesses are more likely to succeed if they treat their operations like a franchise. in a nutshell, this means standardizing and documenting their business processes. There's no better way to do that than with flowcharts, right? Training materials are often created using flowcharts because they're visually stimulating and easy to understand. A nicely laid out flowchart will gain and hold the reader's attention when a block of text will often fail. Workflow Management and Continuous Improvement Workflows don't manage themselves. To ensure that you are meeting your customers' needs, you need to take control of your business processes. The first step to workflow management is to define the current state of your processes by creating an \"As-Is Flowchart\". That allows you to analyze your processes for waste and inefficiency. After you have identified areas for process improvement, you can then craft new flowcharts to document the leaner processes. Programming Information technology played a big influence on the use and spread of flowcharts in the 20th century. While Dr. W. Edwards Deming was advocating their use in quality management, professionals in the data processing world were using them to flesh out their programming logic. Flowcharts were a mainstay of procedural programming, however, and with the advent of object oriented programming and various modeling tools, the use of flowcharts for programming is no longer as commonplace as it once was. That said, even with in the scope of object oriented programming, complex program logic can be modeled effectively using a flowchart. Moreover, diagramming the user's experience as they navigate through a program is a valuable prerequisite prior to designing the user interface. So flowcharts still have their place in the world of programming. Troubleshooting Guides Most of us have come across a troubleshooting flowchart at one time or another. These are usually in the form of Decision Trees that progressively narrow the range of possible solutions based on a series of criteria. The effectiveness of these types of flowcharts depends on how neatly the range of problems and solutions can fit into a simple True/False diagnosis model. A well done troubleshooting flowcharts can cut the problem solving time greatly. Regulatory and Quality Management Requirements Your business processes may be subject to regulatory requirements such as Sarbanes-Oxley (SOX), which requires that your accounting procedures be clearly defined and documented. An easy way to do this is to create accounting flowcharts for all your accounting processes. Similarly, many organizations fall under certification requirements for quality management systems - such as ISO 9000, TS 16949, or one of the many others. In such environments, flowcharts are not only useful but in certain clauses they are actually mandated.","title":"How are they useful?"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#psuedocode","text":"Define","title":"Psuedocode"},{"location":"1-programming/8-algorithmbuildingblocks/algorithmbuildingblocks/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Readings"},{"location":"1-programming/9-sequentialstructures/sequentialstructures/","text":"Sequential Structures Sequential processing are steps performed in sequence, one after another. A spreadsheet computation from top-to-bottom is a sequential process. Reliability Example Suppose we wish to estimate the reliability of a system comprised of many indetical parts iused in multiple places in a design, for instance rivets on an airplane wing. Using a Bernoulli model (which you will see in your statistics class) we can estimate the collective reliability of the system (all the parts work as desired). The reliability is expressed as the fraction of time that no parts have failed, if the fraction is small we would want to either improve part reliability, or ensure redundancy so the system can function with broken parts. Let p be the probability a single component is good and N be the total number of components in the system that work together in a \"series\" context. The reliability, or the percentage of time that none of the components have failed is given by the Bernoulli equation: \\% = (\\frac{p}{100.0})^N \\cdot 100.0 Suppose we want a script to read in a component probability and count, and estimate system reliability -- we can apply our problem solving protocol and JupyterLab to do so, and the task will be mostly sequential Step 1 Problem Statement Estimate the reliability of a component in an instrument relative to a group of components using a Bernoulli approximation. Step 2 Input/Output Decomposition Inputs are the reliability of a single component and the number of components working together in a system, output is estimate of system reliability, governing principle is the Bernoulli equation above. Step 3 By-Hand Example SUppose the system is a small FPGA with 20 transistors, each with reliability of 96-percent. The entire array reliability is \\text{percentage} = (\\frac{96.0}{100.0})^{20} \\cdot 100.0 = 44.2\\% Step 4 Algorithm Development Decompose the computation problem as: Read reliability of a single component Read how many components Compute reliability by bernoulli model Report result Step 5 Scripting Written as a sequence we can have component = float(input('Component Reliability (percentage-numeric)?')) howmany = int(input('Number of Components (integer-numeric)?')) reliability = 100.0*(component/100.0)**howmany print('Component Reliability: ',round(component,1)) print('Number of Components : ',howmany) print('System Relability is : ',round(reliability,1),'%') Component Reliability (percentage-numeric)? 96 Number of Components (integer-numeric)? 20 Component Reliability: 96.0 Number of Components : 20 System Relability is : 44.2 % Step 6 Refinement We have tested the script with the by-hand example, no refinement really needed here, but lets apply to new conditions component = float(input('Component Reliability (percentage-numeric)?')) howmany = int(input('Number of Components (integer-numeric)?')) reliability = 100.0*(component/100.0)**howmany print('Component Reliability: ',round(component,1)) print('Number of Components : ',howmany) print('System Relability is : ',round(reliability,1),'%') Component Reliability (percentage-numeric)? 99 Number of Components (integer-numeric)? 20 Component Reliability: 99.0 Number of Components : 20 System Relability is : 81.8 % References Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. (https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365) Theodore G. Cleveland, Farhang Forghanparast, Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi. (2021) Computational Thinking and Data Science: A WebBook to Accompany ENGR 1330 at TTU, Whitacre College of Engineering, DOI (pending) https://3.137.111.182/engr-1330-webroot/engr-1330-webbook/ctds-psuedocourse/site/ Readings Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Sequential Structures"},{"location":"1-programming/9-sequentialstructures/sequentialstructures/#sequential-structures","text":"Sequential processing are steps performed in sequence, one after another. A spreadsheet computation from top-to-bottom is a sequential process. Reliability Example Suppose we wish to estimate the reliability of a system comprised of many indetical parts iused in multiple places in a design, for instance rivets on an airplane wing. Using a Bernoulli model (which you will see in your statistics class) we can estimate the collective reliability of the system (all the parts work as desired). The reliability is expressed as the fraction of time that no parts have failed, if the fraction is small we would want to either improve part reliability, or ensure redundancy so the system can function with broken parts. Let p be the probability a single component is good and N be the total number of components in the system that work together in a \"series\" context. The reliability, or the percentage of time that none of the components have failed is given by the Bernoulli equation: \\% = (\\frac{p}{100.0})^N \\cdot 100.0 Suppose we want a script to read in a component probability and count, and estimate system reliability -- we can apply our problem solving protocol and JupyterLab to do so, and the task will be mostly sequential Step 1 Problem Statement Estimate the reliability of a component in an instrument relative to a group of components using a Bernoulli approximation. Step 2 Input/Output Decomposition Inputs are the reliability of a single component and the number of components working together in a system, output is estimate of system reliability, governing principle is the Bernoulli equation above. Step 3 By-Hand Example SUppose the system is a small FPGA with 20 transistors, each with reliability of 96-percent. The entire array reliability is \\text{percentage} = (\\frac{96.0}{100.0})^{20} \\cdot 100.0 = 44.2\\% Step 4 Algorithm Development Decompose the computation problem as: Read reliability of a single component Read how many components Compute reliability by bernoulli model Report result Step 5 Scripting Written as a sequence we can have component = float(input('Component Reliability (percentage-numeric)?')) howmany = int(input('Number of Components (integer-numeric)?')) reliability = 100.0*(component/100.0)**howmany print('Component Reliability: ',round(component,1)) print('Number of Components : ',howmany) print('System Relability is : ',round(reliability,1),'%') Component Reliability (percentage-numeric)? 96 Number of Components (integer-numeric)? 20 Component Reliability: 96.0 Number of Components : 20 System Relability is : 44.2 % Step 6 Refinement We have tested the script with the by-hand example, no refinement really needed here, but lets apply to new conditions component = float(input('Component Reliability (percentage-numeric)?')) howmany = int(input('Number of Components (integer-numeric)?')) reliability = 100.0*(component/100.0)**howmany print('Component Reliability: ',round(component,1)) print('Number of Components : ',howmany) print('System Relability is : ',round(reliability,1),'%') Component Reliability (percentage-numeric)? 99 Number of Components (integer-numeric)? 20 Component Reliability: 99.0 Number of Components : 20 System Relability is : 81.8 %","title":"Sequential Structures"},{"location":"1-programming/9-sequentialstructures/sequentialstructures/#references","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapters 3-6 https://www.inferentialthinking.com/chapters/03/programming-in-python.html Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) (https://www.learnpython.org/) Short, interactive tutorial for those who just need a quick way to pick up Python syntax. Brian Christian and Tom Griffiths (2016) ALGORITHMS TO LIVE BY: The Computer Science of Human Decisions Henry Holt and Co. (https://www.amazon.com/Algorithms-Live-Computer-Science-Decisions/dp/1627790365) Theodore G. Cleveland, Farhang Forghanparast, Dinesh Sundaravadivelu Devarajan, Turgut Batuhan Baturalp (Batu), Tanja Karp, Long Nguyen, and Mona Rizvi. (2021) Computational Thinking and Data Science: A WebBook to Accompany ENGR 1330 at TTU, Whitacre College of Engineering, DOI (pending) https://3.137.111.182/engr-1330-webroot/engr-1330-webbook/ctds-psuedocourse/site/","title":"References"},{"location":"1-programming/9-sequentialstructures/sequentialstructures/#readings","text":"Learn Python in One Day and Learn It Well. Python for Beginners with Hands-on Project. (Learn Coding Fast with Hands-On Project Book -- Kindle Edition by LCF Publishing (Author), Jamie Chan https://www.amazon.com/Python-2nd-Beginners-Hands-Project-ebook/dp/B071Z2Q6TQ/ref=sr_1_3?dchild=1&keywords=learn+python+in+a+day&qid=1611108340&sr=8-3 Learn Python the Hard Way (Online Book) (https://learnpythonthehardway.org/book/) Recommended for beginners who want a complete course in programming with Python. How to Learn Python for Data Science, The Self-Starter Way (https://elitedatascience.com/learn-python-for-data-science) Flowcharts (QA/QC Perspective) https://asq.org/quality-resources/flowchart Flowcharts - Wikipedia https://en.wikipedia.org/wiki/Flowchart Psuedocode - Wikipedia https://en.wikipedia.org/wiki/Pseudocode","title":"Readings"},{"location":"1-programming/lesson0/lesson0/","text":"Introduction to Computational Thinking and Data Science: Last GitHub Commit Date: 13 January 2021 Topics Computational thinking concepts Data science and practices JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach Computational Thinking Concepts Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from ( https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/ ). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing ( http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf ). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case. CT Foundations CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation) Decomposition Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Examples include: - Writing a paper: - Introduction - Body - Conclusion Wide-viewed (Panorama) image: Taking multiple overlapped photos Stitch them Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution. Pattern Recognition Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution. Abstraction Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ... Algorithms Step-by-step instructions of how to solve a problem https://en.wikipedia.org/wiki/Algorithm . Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input. System Integration (implementation) System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand. Data Science and Practice Data science (DS) is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills https://elitedatascience.com/data-science-resources : Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges Throughout the remainder of this book we use the acronym CTDS to refer to the collective activities of Computational Thinking and Data Science JupyterLab (iPython) Environment The tools: JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM). This course: You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs. Python The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence. Good Resources: Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science Programming as a problem solving process The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method https://en.wikipedia.org/wiki/Scientific_method is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4). Nevertheless, the result is a method one can always return to and employ for the problem (usually decomposed into small enough sub-problems!). So the whole CTDS as a problem solving tool boils down to a straightforward adaptation of the scientific method. Example 1 Problem Solving Process This example considers a need to compute an arithmetic mean, and what the process might look like. The example goes through the steps involved, and even includes some JupyterLab/iPython scripting; students are not expected to understand the code syntax at this point, but it is included to illustrate an end result of the simple directive to compute a mean value. Step 1. Develop script to compute the arithmetic mean of a stream of data of unknown length. Step 2. - Inputs: The data stream - Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. - Outputs: The arithmetic mean \\bar x Step 3. Work a sample problem by-hand for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95 Step 4. Develop a general solution (code) The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. In a flow-chart it would look like: Flowchart for Artihmetic Mean Algorithm Step 5. This step we would code the algorithm expressed in the figure and test it with the by-hand data and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",(accumulator/howlong)) arithmetic mean = 30.951999999999998 Step 6. This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed than it first appears, but illustrates a five step process (with a refinement step). Keep in mind throughout the course this generic process is always going on in the background. CCMR Approach A lot of the problems we will encounter from a CTDS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution (or something close) to your problem from some source: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like the references below, but a URL to the source is sufficient as a first step. Modify: Modify the original cited work for your specific needs. Note the changes you make in the code using comment statements, include the original source URL in a preamble comment. Run: Apply the modified code to your problem. In cases where we use CCMR we are not so much programming and developing our own work as we are assembling (scaffolding) parts together (System Integration)( https://en.wikipedia.org/wiki/Scaffold_(programming)https://en.wikipedia.org/wiki/Scaffold_(programming) - a legitimate, valuable, and usually profitable engineering activity. Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Introduction to Computational Thinking and Data Science:"},{"location":"1-programming/lesson0/lesson0/#introduction-to-computational-thinking-and-data-science","text":"Last GitHub Commit Date: 13 January 2021","title":"Introduction to Computational Thinking and Data Science:"},{"location":"1-programming/lesson0/lesson0/#topics","text":"Computational thinking concepts Data science and practices JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach","title":"Topics"},{"location":"1-programming/lesson0/lesson0/#computational-thinking-concepts","text":"Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from ( https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/ ). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing ( http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf ). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case.","title":"Computational Thinking Concepts"},{"location":"1-programming/lesson0/lesson0/#ct-foundations","text":"CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation)","title":"CT Foundations"},{"location":"1-programming/lesson0/lesson0/#decomposition","text":"Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Examples include: - Writing a paper: - Introduction - Body - Conclusion Wide-viewed (Panorama) image: Taking multiple overlapped photos Stitch them Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution.","title":"Decomposition"},{"location":"1-programming/lesson0/lesson0/#pattern-recognition","text":"Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution.","title":"Pattern Recognition"},{"location":"1-programming/lesson0/lesson0/#abstraction","text":"Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ...","title":"Abstraction"},{"location":"1-programming/lesson0/lesson0/#algorithms","text":"Step-by-step instructions of how to solve a problem https://en.wikipedia.org/wiki/Algorithm . Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input.","title":"Algorithms"},{"location":"1-programming/lesson0/lesson0/#system-integration-implementation","text":"System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand.","title":"System Integration (implementation)"},{"location":"1-programming/lesson0/lesson0/#data-science-and-practice","text":"Data science (DS) is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills https://elitedatascience.com/data-science-resources : Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges Throughout the remainder of this book we use the acronym CTDS to refer to the collective activities of Computational Thinking and Data Science","title":"Data Science and Practice"},{"location":"1-programming/lesson0/lesson0/#jupyterlab-ipython-environment","text":"","title":"JupyterLab (iPython) Environment"},{"location":"1-programming/lesson0/lesson0/#the-tools","text":"JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM).","title":"The tools:"},{"location":"1-programming/lesson0/lesson0/#this-course","text":"You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs.","title":"This course:"},{"location":"1-programming/lesson0/lesson0/#python","text":"The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.","title":"Python"},{"location":"1-programming/lesson0/lesson0/#good-resources","text":"Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science","title":"Good Resources:"},{"location":"1-programming/lesson0/lesson0/#programming-as-a-problem-solving-process","text":"The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method https://en.wikipedia.org/wiki/Scientific_method is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4). Nevertheless, the result is a method one can always return to and employ for the problem (usually decomposed into small enough sub-problems!). So the whole CTDS as a problem solving tool boils down to a straightforward adaptation of the scientific method.","title":"Programming as a problem solving process"},{"location":"1-programming/lesson0/lesson0/#example-1-problem-solving-process","text":"This example considers a need to compute an arithmetic mean, and what the process might look like. The example goes through the steps involved, and even includes some JupyterLab/iPython scripting; students are not expected to understand the code syntax at this point, but it is included to illustrate an end result of the simple directive to compute a mean value. Step 1. Develop script to compute the arithmetic mean of a stream of data of unknown length. Step 2. - Inputs: The data stream - Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. - Outputs: The arithmetic mean \\bar x Step 3. Work a sample problem by-hand for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95 Step 4. Develop a general solution (code) The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. In a flow-chart it would look like: Flowchart for Artihmetic Mean Algorithm Step 5. This step we would code the algorithm expressed in the figure and test it with the by-hand data and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",(accumulator/howlong)) arithmetic mean = 30.951999999999998 Step 6. This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed than it first appears, but illustrates a five step process (with a refinement step). Keep in mind throughout the course this generic process is always going on in the background.","title":"Example 1 Problem Solving Process"},{"location":"1-programming/lesson0/lesson0/#ccmr-approach","text":"A lot of the problems we will encounter from a CTDS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution (or something close) to your problem from some source: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like the references below, but a URL to the source is sufficient as a first step. Modify: Modify the original cited work for your specific needs. Note the changes you make in the code using comment statements, include the original source URL in a preamble comment. Run: Apply the modified code to your problem. In cases where we use CCMR we are not so much programming and developing our own work as we are assembling (scaffolding) parts together (System Integration)( https://en.wikipedia.org/wiki/Scaffold_(programming)https://en.wikipedia.org/wiki/Scaffold_(programming) - a legitimate, valuable, and usually profitable engineering activity.","title":"CCMR Approach"},{"location":"1-programming/lesson0/lesson0/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Readings"},{"location":"2-datamodeling/23-datamodelsandvisualization/datamodelsandvisualization/","text":"data models and visualization interpolation using lagrange polynomials fitting an arbitrary function (trial-and-error) fitting a polynomial (linear system solver)","title":"Data Models and Visualization"},{"location":"2-datamodeling/23-datamodelsandvisualization/datamodelsandvisualization/#data-models-and-visualization","text":"interpolation using lagrange polynomials fitting an arbitrary function (trial-and-error) fitting a polynomial (linear system solver)","title":"data models and visualization"},{"location":"data_models_statistical/datamod-stats1/","text":"# Script block to identify host, user, and kernel import sys ! echo 'HID : ' $HOSTNAME ! echo 'UID : ' $USER ! pwd print(sys.executable) #print(sys.version) #print(sys.version_info) HID : atomickitty UID : sensei /home/sensei/1330-textbook-webroot/ctds-webbook/docs/data_models_statistical /opt/jupyterhub/bin/python3 %%html <!-- Script Block to set tables to left alignment --> <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} Data Models : Statistical Approaches Last GitHub Commit Date: 13 January 2021 Topics list them here, maybe multiple files Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Datamod stats1"},{"location":"data_models_statistical/datamod-stats1/#data-models-statistical-approaches","text":"Last GitHub Commit Date: 13 January 2021","title":"Data Models : Statistical Approaches"},{"location":"data_models_statistical/datamod-stats1/#topics","text":"list them here, maybe multiple files","title":"Topics"},{"location":"data_models_statistical/datamod-stats1/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Readings"},{"location":"introduction/intro-1/","text":"table {margin-left: 0 !important;} Introduction to Computational Thinking and Data Science: Last GitHub Commit Date: 13 January 2021 Topics Computational thinking concepts Data science and practices JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach Computational Thinking Concepts Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from ( https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/ ). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing ( http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf ). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case. CT Foundations CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation) Decomposition Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Examples include: - Writing a paper: - Introduction - Body - Conclusion Wide-viewed (Panorama) image: Taking multiple overlapped photos Stitch them Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution. Pattern Recognition Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution. Abstraction Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ... Algorithms Step-by-step instructions of how to solve a problem https://en.wikipedia.org/wiki/Algorithm . Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input. System Integration (implementation) System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand. Data Science and Practice Data science (DS) is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills https://elitedatascience.com/data-science-resources : Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges Throughout the remainder of this book we use the acronym CTDS to refer to the collective activities of Computational Thinking and Data Science JupyterLab (iPython) Environment The tools: JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM). This course: You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs. Python The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence. Good Resources: Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science Programming as a problem solving process The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method https://en.wikipedia.org/wiki/Scientific_method is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4). Nevertheless, the result is a method one can always return to and employ for the problem (usually decomposed into small enough sub-problems!). So the whole CTDS boils down (distills) to a variation of the scientific method. CCMR Approach A lot of the problems we will encounter from a CTDS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution (or something close) to your problem from some source: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like the references below, but a URL to the source is sufficient as a first step. Modify: Modify the original cited work for your specific needs. Note the changes you make in the code using comment statements, include the original source URL in a preamble comment. Run: Apply the modified code to your problem. In cases where we use CCMR we are not so much programming and developing our own work as we are assembling (scaffolding) parts together (System Integration)( https://en.wikipedia.org/wiki/Scaffold_(programming)https://en.wikipedia.org/wiki/Scaffold_(programming) - a legitimate, valuable, and usually profitable engineering activity. Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Intro 1"},{"location":"introduction/intro-1/#introduction-to-computational-thinking-and-data-science","text":"Last GitHub Commit Date: 13 January 2021","title":"Introduction to Computational Thinking and Data Science:"},{"location":"introduction/intro-1/#topics","text":"Computational thinking concepts Data science and practices JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach","title":"Topics"},{"location":"introduction/intro-1/#computational-thinking-concepts","text":"Computational thinking (CT) refers to the thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer. Much of what follows is borrowed from ( https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2696102/ ). Computational thinking is taking an approach to solving problems, designing systems and understanding human behaviour that draws on concepts fundamental to computing ( http://www.cs.cmu.edu/~15110-s13/Wing06-ct.pdf ). Computational thinking is a kind of analytical thinking: It shares with mathematical thinking in the general ways in which we might approach solving a problem. It shares with engineering thinking in the general ways in which we might approach designing and evaluating a large, complex system that operates within the constraints of the real world. - It shares with scientific thinking in the general ways in which we might approach understanding computability, intelligence, the mind and human behaviour. The essence of computational thinking is abstraction and automation . In computing, we abstract notions beyond the physical dimensions of time and space. Our abstractions are extremely general because they are symbolic, where numeric abstractions are just a special case.","title":"Computational Thinking Concepts"},{"location":"introduction/intro-1/#ct-foundations","text":"CT is literally a process for breaking down a problem into smaller parts, looking for patterns in the problems, identifying what kind of information is needed, developing a step-by-step solution, and implementing that solution. Decomposition Pattern Recognition Abstraction Algorithms System Integration (implementation)","title":"CT Foundations"},{"location":"introduction/intro-1/#decomposition","text":"Decomposition is the process of taking a complex problem and breaking it into more manageable sub-problems. Examples include: - Writing a paper: - Introduction - Body - Conclusion Wide-viewed (Panorama) image: Taking multiple overlapped photos Stitch them Decomposition often leaves a framework of sub-problems that later have to be assembled (system integration) to produce a desired solution.","title":"Decomposition"},{"location":"introduction/intro-1/#pattern-recognition","text":"Refers to finding similarities, or shared characteristics of problems. Allows a complex problem to become easier to solve. Allows use of same solution method for each occurrence of the pattern. Pattern recognition allows use of automation to process things - its a fundamental drilled shaft of CT. It also provides a way to use analogs from old problems to address new situations; it also will require assembly (system integration) to produce a desired solution.","title":"Pattern Recognition"},{"location":"introduction/intro-1/#abstraction","text":"Determine important characteristics of the problem and ignore characteristics that are not important. Use these characteristics to create a representation of what we are trying to solve. Books in an online bookstore Important NOT important title Cover color ISBN Author\u2019s hometown Authors ... ... ...","title":"Abstraction"},{"location":"introduction/intro-1/#algorithms","text":"Step-by-step instructions of how to solve a problem https://en.wikipedia.org/wiki/Algorithm . Identifies what is to be done, and the order in which they should be done. Image from https://www.newyorker.com/magazine/2021/01/18/whats-wrong-with-the-way-we-work?utm_source=pocket-newtab An algorithm is a finite sequence of defined, instructions, typically to solve a class of problems or to perform a computation. Algorithms are unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of defined successive states, eventually producing \"output\" and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, can incorporate random input.","title":"Algorithms"},{"location":"introduction/intro-1/#system-integration-implementation","text":"System integration is the assembly of the parts above into the complete (integrated) solution. Integration combines parts into a program which is the realization of an algorithm using a syntax that the computer can understand.","title":"System Integration (implementation)"},{"location":"introduction/intro-1/#data-science-and-practice","text":"Data science (DS) is leveraging existing data sources, to create new ones as needed in order to extract meaningful information and actionable insights through business domain expertise, effective communication and results interpretation. Data science uses relevant statistical techniques, programming languages, software packages and libraries, and data infrastructure; The insights are used to drive business decisions and take actions intended to achieve business goals. Why is this important for engineers? Because engineering is a business! A list of typical skills https://elitedatascience.com/data-science-resources : Foundational Skills Programming and Data Manipulation Statistics and Probability Technical Skills Data Collection SQL Data Visualization Applied Machine Learning Business Skills Communication Creativity and Innovation Operations and Strategy Business Analytics Supplementary Skills Natural Language Processing Recommendation Systems Time Series Analysis Practice Projects Competitions Problem Solving Challenges Throughout the remainder of this book we use the acronym CTDS to refer to the collective activities of Computational Thinking and Data Science","title":"Data Science and Practice"},{"location":"introduction/intro-1/#jupyterlab-ipython-environment","text":"","title":"JupyterLab (iPython) Environment"},{"location":"introduction/intro-1/#the-tools","text":"JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM).","title":"The tools:"},{"location":"introduction/intro-1/#this-course","text":"You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs.","title":"This course:"},{"location":"introduction/intro-1/#python","text":"The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.","title":"Python"},{"location":"introduction/intro-1/#good-resources","text":"Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science","title":"Good Resources:"},{"location":"introduction/intro-1/#programming-as-a-problem-solving-process","text":"The entire point of this course is to develop problem solving skills and begin using some tools (Statistics, Numerical Methods, Data Science, implemented as JupyterLab/Python programs). The scientific method https://en.wikipedia.org/wiki/Scientific_method is one example of an effective problem solving strategy. Stated as a protocol it goes something like: Observation: Formulation of a question Hypothesis: A conjecture that may explain observed behavior. Falsifiable by an experiment whose outcome conflicts with predictions deduced from the hypothesis Prediction: How the experiment should conclude if hypothesis is correct Testing: Experimental design, and conduct of the experiment. Analysis: Interpretation of experimental results This protocol can be directly adapted to CT/DS problems as: Define the problem (problem statement) Gather information (identify known and unknown values, and governing equations) Generate and evaluate potential solutions Refine and implement a solution Verify and test the solution. For actual computational methods the protocol becomes: Explicitly state the problem State: Input information Governing equations or principles, and The required output information. Work a sample problem by-hand for testing the general solution. Develop a general solution method (coding). Test the general solution against the by-hand example, then apply to the real problem. Oddly enough the first step is the most important and sometimes the most difficult. In a practical problem, step 2 is sometimes difficult because a skilled programmer is needed to translate the governing principles into an algorithm for the general solution (step 4). Nevertheless, the result is a method one can always return to and employ for the problem (usually decomposed into small enough sub-problems!). So the whole CTDS boils down (distills) to a variation of the scientific method.","title":"Programming as a problem solving process"},{"location":"introduction/intro-1/#ccmr-approach","text":"A lot of the problems we will encounter from a CTDS perspective have already been solved, or at least analogs have been solved. It is perfectly acceptable to use prior work for a new set of conditions as long as proper attribution is made. We call this process CCMR: Copy: Find a solution (or something close) to your problem from some source: SourceForge, StackOverflow, GeeksForGeeks, DigitalOcean, etc. Cite: Cite the original source. In general a citation will look like the references below, but a URL to the source is sufficient as a first step. Modify: Modify the original cited work for your specific needs. Note the changes you make in the code using comment statements, include the original source URL in a preamble comment. Run: Apply the modified code to your problem. In cases where we use CCMR we are not so much programming and developing our own work as we are assembling (scaffolding) parts together (System Integration)( https://en.wikipedia.org/wiki/Scaffold_(programming)https://en.wikipedia.org/wiki/Scaffold_(programming) - a legitimate, valuable, and usually profitable engineering activity.","title":"CCMR Approach"},{"location":"introduction/intro-1/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Readings"},{"location":"introduction/intro-2/","text":"How to Build a Program The design protocol below, is similar to the 6-step process described in the previous part. This document is shamelessly lifted from http://users.csc.calpoly.edu/~jdalbey/101/Lectures/HowToBuildAProgram.html here I am using the concept of program and notebook as the same thing. Building a program is not an art, it is an engineering process. As such there is a process to follow with clearly defined steps. Analysis (Understand the Requirements) In this class you will be given the problem requirements, unlike the real-world where you have to elicit the requirements from a customer. For you the first step will be to read the problem and be sure you understand what the program must do. Summarize your understanding by writing the Input data, Output data, and Functions (operations or transformation on the data). Create a Test Plan You must be able to verify that your program works correctly once it is written. Invent some actual input data values and manually compute the expected result. Invent a Solution This is the creative, exploratory part of design where you figure out how to solve the problem. Here is one strategy: Solve the problem manually, the way you would do it as a human. Pay careful to attention what operations you perform and write down each step. Look for a pattern in the steps you performed. Determine how this pattern could be automated using the 3 algorithm building blocks (Sequence, Selection, Iteration). Design (Formalize your solution) Arrange your solution into components; this is called the architecture. Write the algorithm for each component. Refine your algorithm in a step-wise manner if necessary. Determine the data types and constraints for each data item. Review Perform a hand trace of your solution and simulate how the computer will carry out your algorithm. Make sure your algorithm works correctly before you put it into the computer. Implementation (coding) Translate your algorithm into a programming language and enter it into the computer. Compile your source code to produce an executable program. You may want to compile and test each subprogram individually before combining them into a complete program. Testing Execute the program using the Test Plans you created above. Correct any errors as necessary.","title":"How to Build a Program"},{"location":"introduction/intro-2/#how-to-build-a-program","text":"The design protocol below, is similar to the 6-step process described in the previous part. This document is shamelessly lifted from http://users.csc.calpoly.edu/~jdalbey/101/Lectures/HowToBuildAProgram.html here I am using the concept of program and notebook as the same thing. Building a program is not an art, it is an engineering process. As such there is a process to follow with clearly defined steps.","title":"How to Build a Program"},{"location":"introduction/intro-2/#analysis-understand-the-requirements","text":"In this class you will be given the problem requirements, unlike the real-world where you have to elicit the requirements from a customer. For you the first step will be to read the problem and be sure you understand what the program must do. Summarize your understanding by writing the Input data, Output data, and Functions (operations or transformation on the data).","title":"Analysis (Understand the Requirements)"},{"location":"introduction/intro-2/#create-a-test-plan","text":"You must be able to verify that your program works correctly once it is written. Invent some actual input data values and manually compute the expected result.","title":"Create a Test Plan"},{"location":"introduction/intro-2/#invent-a-solution","text":"This is the creative, exploratory part of design where you figure out how to solve the problem. Here is one strategy: Solve the problem manually, the way you would do it as a human. Pay careful to attention what operations you perform and write down each step. Look for a pattern in the steps you performed. Determine how this pattern could be automated using the 3 algorithm building blocks (Sequence, Selection, Iteration).","title":"Invent a Solution"},{"location":"introduction/intro-2/#design-formalize-your-solution","text":"Arrange your solution into components; this is called the architecture. Write the algorithm for each component. Refine your algorithm in a step-wise manner if necessary. Determine the data types and constraints for each data item. Review Perform a hand trace of your solution and simulate how the computer will carry out your algorithm. Make sure your algorithm works correctly before you put it into the computer.","title":"Design (Formalize your solution)"},{"location":"introduction/intro-2/#implementation-coding","text":"Translate your algorithm into a programming language and enter it into the computer. Compile your source code to produce an executable program. You may want to compile and test each subprogram individually before combining them into a complete program.","title":"Implementation (coding)"},{"location":"introduction/intro-2/#testing","text":"Execute the program using the Test Plans you created above. Correct any errors as necessary.","title":"Testing"},{"location":"introduction/intro-3/","text":"table {margin-left: 0 !important;} Example 1 Problem Solving Process - Compute Arithmetic Mean This example considers a need to compute an arithmetic mean, and what the process might look like. The example goes through the steps involved, and even includes some JupyterLab/iPython scripting; students are not expected to understand the code syntax at this point, but it is included to illustrate an end result of the simple directive to compute a mean value. Step 1. Problem Statement Develop script to compute the arithmetic mean of a stream of data of unknown length. Step 2. Identify inputs, outputs, governing principles For this example these are straightforward enough to simply itemize: Inputs: The data stream Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. Outputs: The arithmetic mean \\bar x Step 3. Create a sample problem Create a sample problem suitable for \"by-hand\" execution for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95 Step 4 Develop a general solution (Algorithm) Here is where we create an algorithm. The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. In a flow-chart it would look like: Flowchart for Artihmetic Mean Algorithm Step 5. Generalization (Algorithm into Code) Convert the algorithm expressed in the above into running code and test it with the \"by-hand\" example, and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",(accumulator/howlong)) arithmetic mean = 30.951999999999998 Step 6. Refinement. This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed than it first appears, but illustrates a five step process (with a refinement step). Keep in mind throughout the course this generic process is always going on in the background.","title":"Intro 3"},{"location":"introduction/intro-3/#example-1-problem-solving-process-compute-arithmetic-mean","text":"This example considers a need to compute an arithmetic mean, and what the process might look like. The example goes through the steps involved, and even includes some JupyterLab/iPython scripting; students are not expected to understand the code syntax at this point, but it is included to illustrate an end result of the simple directive to compute a mean value.","title":"Example 1 Problem Solving Process - Compute Arithmetic Mean"},{"location":"introduction/intro-3/#step-1-problem-statement","text":"Develop script to compute the arithmetic mean of a stream of data of unknown length.","title":"Step 1. Problem Statement"},{"location":"introduction/intro-3/#step-2-identify-inputs-outputs-governing-principles","text":"For this example these are straightforward enough to simply itemize: Inputs: The data stream Governing equation: \\bar x = \\frac{1}{N} \\sum_{i=1}^{N} x_i where N is the number of items in the data stream, and x_i is the value of the i-th element. Outputs: The arithmetic mean \\bar x","title":"Step 2. Identify inputs, outputs, governing principles"},{"location":"introduction/intro-3/#step-3-create-a-sample-problem","text":"Create a sample problem suitable for \"by-hand\" execution for testing the general solution. Data 23.43 37.43 34.91 28.37 30.62 The arithmetic mean requires us to count how many elements are in the data stream (in this case there are 5) and compute their sum (in this case 154.76), and finally divide the sum by the count and report this result as the arithmetic mean. \\bar x = \\frac{1}{5}(23.43+37.43+34.91+28.37+30.62)=\\frac{154.76}{5}=30.95","title":"Step 3. Create a sample problem"},{"location":"introduction/intro-3/#step-4-develop-a-general-solution-algorithm","text":"Here is where we create an algorithm. The by-hand exercise helps identify the required steps in an \u201calgorithm\u201d or recipe to compute mean values. First we essentially capture or read the values then count how many there are (either as we go or as a separate step), then sum the values, then divide the values by the count, and finally report the result. In a flow-chart it would look like: Flowchart for Artihmetic Mean Algorithm","title":"Step 4 Develop a general solution (Algorithm)"},{"location":"introduction/intro-3/#step-5-generalization-algorithm-into-code","text":"Convert the algorithm expressed in the above into running code and test it with the \"by-hand\" example, and other small datasets until we are convinced it works correctly. In a simple JupyterLab script # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",(accumulator/howlong)) arithmetic mean = 30.951999999999998","title":"Step 5. Generalization (Algorithm into Code)"},{"location":"introduction/intro-3/#step-6-refinement","text":"This step we would refine the code to generalize the algorithm. In the example we want a way to supply the xlist from a file perhaps, and tidy the output by rounding to only two decimal places - rounding is relatively simple: # Arithmetic Mean in Very Elementary and Primative Python xlist = [23.43,37.43,34.91,28.37,30.62] # list is a type of data structure howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + xlist[i] print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Reading from a file, is a bit more complicated. We need to create a connection to the file, then read the contents into our script, then put the contents into the xlist xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection howlong = len(xlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(xlist[i]) print(\"arithmetic mean = \",round((accumulator/howlong),2)) arithmetic mean = 30.95 Finally, if we want to reuse the code a lot, it is convienent to make it into a function def average(inputlist): # inputlist should be a list of values howlong = len(inputlist) # len is a built-in function that returns how many items in a list accumulator = 0 # a variable to accumulate the sum for i in range(howlong): accumulator = accumulator + float(inputlist[i]) result = (accumulator/howlong) return(result) Put our file reading and compute mean code here xlist=[] # list (null) is a type of data structure externalfile = open(\"data.txt\",'r') # create connection to file, set to read (r), file must exist how_many_lines = 0 for line in externalfile: # parse each line, append to xlist xlist.append(line) how_many_lines += 1 externalfile.close() # close the file connection print(\"arithmetic mean = \",round(average(xlist),2)) arithmetic mean = 30.95 So the simple task of computing the mean of a collection of values, is a bit more complex when decomposed than it first appears, but illustrates a five step process (with a refinement step). Keep in mind throughout the course this generic process is always going on in the background.","title":"Step 6. Refinement."},{"location":"jupyterlab_python/jupyterlab-1/","text":"# Script block to identify host, user, and kernel import sys ! echo 'HID : ' $HOSTNAME ! echo 'UID : ' $USER ! pwd print(sys.executable) #print(sys.version) #print(sys.version_info) HID : atomickitty UID : sensei /home/sensei/1330-textbook-webroot/ctds-webbook/docs/lesson0 /opt/jupyterhub/bin/python3 %%html <!-- Script Block to set tables to left alignment --> <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} JupyterLab/iPython Fundamentals Last GitHub Commit Date: none Topics JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach JupyterLab (iPython) Environment The tools: JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM). This course: You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs. Python The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence. Good Resources: Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science Readings Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Jupyterlab 1"},{"location":"jupyterlab_python/jupyterlab-1/#jupyterlabipython-fundamentals","text":"Last GitHub Commit Date: none","title":"JupyterLab/iPython Fundamentals"},{"location":"jupyterlab_python/jupyterlab-1/#topics","text":"JupyterLab (iPython) as a programming environment Programming as a problem solving process The CCMR Approach","title":"Topics"},{"location":"jupyterlab_python/jupyterlab-1/#jupyterlab-ipython-environment","text":"","title":"JupyterLab (iPython) Environment"},{"location":"jupyterlab_python/jupyterlab-1/#the-tools","text":"JupyterLab https://jupyter.org/ is a web-based interactive development environment for Jupyter notebooks, code, and data. Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data organizing and transformation, numerical simulation, statistical modeling, visualization, machine learning, and other similar types of uses. JupyterHub https://github.com/jupyterhub/jupyterhub is a multi-user Hub that spawns, manages, and proxies multiple instances of the single-user Jupyter notebook server. All these tools allow use of various coding languages; Python is the choice for ENGR 1330. Installing JupyterLab on your own computer is relatively straightforward if it is an Intel-based Linux, Macintosh, or Windows machine - simply use Anaconda https://www.anaconda.com/ as the installer. Installing onto an ARM-based machine is more difficult, but possible (this notebook was created on a Raspberry Pi). With both Apple and Microsoft abandoning Intel one can only hope for Anaconda builds for aarch64 (ARM).","title":"The tools:"},{"location":"jupyterlab_python/jupyterlab-1/#this-course","text":"You will create and use Jupyter Notebooks that use the ipython kernel, the notebook files will look like filename.ipynb ; these are ASCII files that the JupyterLab interprets and runs.","title":"This course:"},{"location":"jupyterlab_python/jupyterlab-1/#python","text":"The programming language we will use is Python (actually iPython). Python is an example of a high-level language; other high-level languages include C, C++, PHP, FORTRAN, ADA, Pascal, Go, Java, etc (there are a lot). As you might infer from the name high-level language, there are also low-level languages, sometimes referred to as machine languages or assembly languages. Machine language is the encoding of instructions in binary so that they can be directly executed by the computer. Assembly language uses a slightly easier format to refer to the low level instructions. Loosely speaking, computers can only execute programs written in low-level languages. To be exact, computers can actually only execute programs written in machine language. Thus, programs written in a high-level language (and even those in assembly language) have to be processed before they can run. This extra processing takes some time, which is a small disadvantage of high-level languages. However, the advantages to high-level languages are enormous. First, it is much easier to program in a high-level language. Programs written in a high-level language take less time to write, they are shorter and easier to read, and they are more likely to be correct. Second, high-level languages are portable, meaning that they can run on different kinds of computers with few or no modifications. Low-level programs can run on only one kind of computer and have to be rewritten to run on another. Due to these advantages, almost all programs are written in high-level languages. Low-level languages are used only for a few specialized applications, and for device drivers. Two kinds of programs process high-level languages into low-level languages: interpreters and compilers. An interpreter reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. Interpreted Program. Image from https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html A compiler reads the program and translates it completely before the program starts running. In this case, the high-level program is called the source code, and the translated program is called the object code or the executable. Once a program is compiled, you can execute it repeatedly without further translation. Compiled Prorgam. Image from: https://runestone.academy/runestone/books/published/thinkcspy/GeneralIntro/ThePythonProgrammingLanguage.html Many modern languages use both processes. They are first compiled into a lower level language, called byte code, and then interpreted by a program called a virtual machine. Python uses both processes, but because of the way programmers interact with it, it is usually considered an interpreted language. As a language, python is a formal language that has certain requirements and structure called \"syntax.\" Formal languages are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. Programming languages are formal languages that have been designed to express computations. Formal languages have strict rules about syntax. For example, 3+3=6 is a syntactically correct mathematical statement, but 3=+6& is not. Syntax rules come in two flavors, pertaining to tokens and structure . Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems with 3=+6& is that & is not a legal token in mathematics (at least as far as we know). The second type of syntax rule pertains to the structure of a statement\u2014 that is, the way the tokens are arranged. The statement 3=+6& is structurally illegal (in mathematics) because you don\u2019t place a plus sign immediately after an equal sign (of course we will in python!). When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence is; This process is called parsing . For example, when you hear the sentence, \u201cThe other shoe fell\u201d, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or the semantics of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.","title":"Python"},{"location":"jupyterlab_python/jupyterlab-1/#good-resources","text":"Learn Python the Hard Way (Online Book) https://learnpythonthehardway.org/book/ Recommended for beginners who want a complete course in programming with Python. LearnPython.org (Interactive Tutorial) https://www.learnpython.org/ Short, interactive tutorial for those who just need a quick way to pick up Python syntax. How to Think Like a Computer Scientist (Interactive Book) https://runestone.academy/runestone/books/published/thinkcspy/index.html Interactive \"CS 101\" course taught in Python that really focuses on the art of problem solving. How to Learn Python for Data Science, The Self-Starter Way https://elitedatascience.com/learn-python-for-data-science","title":"Good Resources:"},{"location":"jupyterlab_python/jupyterlab-1/#readings","text":"Computational and Inferential Thinking Ani Adhikari and John DeNero, Computational and Inferential Thinking, The Foundations of Data Science, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND) Chapter 1 https://www.inferentialthinking.com/chapters/01/what-is-data-science.htmlhttps://www.inferentialthinking.com/chapters/01/what-is-data-science.html","title":"Readings"},{"location":"numerical_methods/num_methods-1/","text":"%%html <!-- Script Block to set tables to left alignment --> <style> table {margin-left: 0 !important;} </style> table {margin-left: 0 !important;} Useful Numerical Methods: Last GitHub Commit Date: 13 January 2021 Topics Newton's method Integration of Functions Integration of Tabular Data Differentation Approximation Numerical Linear Algebra","title":"Num methods 1"},{"location":"numerical_methods/num_methods-1/#useful-numerical-methods","text":"Last GitHub Commit Date: 13 January 2021","title":"Useful Numerical Methods:"},{"location":"numerical_methods/num_methods-1/#topics","text":"Newton's method Integration of Functions Integration of Tabular Data Differentation Approximation Numerical Linear Algebra","title":"Topics"}]}